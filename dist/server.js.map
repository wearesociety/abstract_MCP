{"version":3,"sources":["../src/server.ts","../src/tools/ab_deployToken.ts","../src/tools/ab_getBalance.ts","../src/utils/viemClient.ts","../src/utils/addressHelpers.ts","../src/constants/tokens.ts","../src/tools/ab_transferToken.ts","../src/tools/ab_agwCreateWallet.ts","../node_modules/@abstract-foundation/agw-client/src/actions/deployAccount.ts","../node_modules/@abstract-foundation/agw-client/src/abis/AccountFactory.ts","../node_modules/@abstract-foundation/agw-client/src/constants.ts","../node_modules/@abstract-foundation/agw-client/src/utils.ts","../node_modules/@abstract-foundation/agw-client/src/eip712.ts","../node_modules/@abstract-foundation/agw-client/src/errors/eip712.ts","../node_modules/@abstract-foundation/agw-client/src/types/call.ts","../node_modules/@abstract-foundation/agw-client/src/actions/getLinkedAccounts.ts","../node_modules/@abstract-foundation/agw-client/src/errors/account.ts","../node_modules/@abstract-foundation/agw-client/src/actions/getLinkedAgw.ts","../node_modules/@abstract-foundation/agw-client/src/sessions.ts","../node_modules/@abstract-foundation/agw-client/src/actions/linkToAgw.ts","../node_modules/@abstract-foundation/agw-client/src/actions/sendTransactionBatch.ts","../node_modules/@abstract-foundation/agw-client/src/actions/sendPrivyTransaction.ts","../node_modules/@abstract-foundation/agw-client/src/actions/sendTransactionInternal.ts","../node_modules/@abstract-foundation/agw-client/src/errors/insufficientBalance.ts","../node_modules/@abstract-foundation/agw-client/src/actions/prepareTransaction.ts","../node_modules/@abstract-foundation/agw-client/src/sessionClient.ts","../node_modules/@abstract-foundation/agw-client/src/walletActions.ts","../node_modules/@abstract-foundation/agw-client/src/abstractClient.ts","../node_modules/@abstract-foundation/agw-client/src/actions/createSession.ts","../node_modules/@abstract-foundation/agw-client/src/actions/deployContract.ts","../node_modules/@abstract-foundation/agw-client/src/actions/sendTransaction.ts","../node_modules/@abstract-foundation/agw-client/src/actions/revokeSessions.ts","../node_modules/@abstract-foundation/agw-client/src/actions/sendTransactionForSession.ts","../node_modules/@abstract-foundation/agw-client/src/actions/signMessage.ts","../node_modules/@abstract-foundation/agw-client/src/getAgwTypedSignature.ts","../node_modules/@abstract-foundation/agw-client/src/actions/signTransaction.ts","../node_modules/@abstract-foundation/agw-client/src/sessionValidator.ts","../node_modules/@abstract-foundation/agw-client/src/actions/signTransactionBatch.ts","../node_modules/@abstract-foundation/agw-client/src/actions/signTransactionForSession.ts","../node_modules/@abstract-foundation/agw-client/src/actions/signTypedData.ts","../node_modules/@abstract-foundation/agw-client/src/actions/writeContract.ts","../node_modules/@abstract-foundation/agw-client/src/actions/writeContractForSession.ts","../src/tools/ab_generateEoaWallet.ts"],"sourcesContent":["import { FastMCP } from \"fastmcp\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore â€“ dotenv types resolution conflict under NodeNext; safe to ignore\nimport * as dotenv from \"dotenv\";\nimport { registerAbDeployToken } from \"./tools/ab_deployToken.js\";\nimport { registerGetBalance } from \"./tools/ab_getBalance.js\";\nimport { registerTransferToken } from \"./tools/ab_transferToken.js\";\nimport { registerAgwCreateWallet } from \"./tools/ab_agwCreateWallet.js\";\nimport { registerGenerateEoaWallet } from \"./tools/ab_generateEoaWallet.js\";\n// import { registerMintNft } from \"./tools/mintNft.js\"; // Temporarily disabled\n// import { registerBridgeNft } from \"./tools/bridgeNft.js\"; // Temporarily disabled\n\n// Load .env file if it exists (optional for development)\ntry {\n    dotenv.config();\n} catch (error) {\n    // .env file is optional - all required variables should come from client\n    console.log(\"No .env file found or failed to load - using environment variables from client\");\n}\n\nexport const server = new FastMCP({ name: \"Society Abstract MCP\", version: \"0.1.0\" });\n\nregisterAbDeployToken(server); // Deploy MyContract using factory pattern\nregisterGetBalance(server);    // Get the balance of an address\nregisterTransferToken(server); // Transfer tokens to an address\nregisterAgwCreateWallet(server); // Deploy a new Abstract Global Wallet (smart-contract account) for a given signer\nregisterGenerateEoaWallet(server); // Generate a brand-new Externally Owned Account (EOA)\n// registerMintNft(server); // Temporarily disabled\n// registerBridgeNft(server); // Temporarily disabled\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n    // Start as stdio server (best practice for FastMCP agents)\n    await server.start();\n} ","import { z } from \"zod\";\nimport { FastMCP, UserError, type ContentResult } from \"fastmcp\";\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\nimport fs from \"fs\";\n\n// ESM-compatible __dirname replacement\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst ParamsSchema = z.object({\n    name: z.string().describe(\"Token name\"),\n    symbol: z.string().describe(\"Token symbol / ticker\"),\n    initialSupply: z\n        .string()\n        .regex(/^\\d+$/, {\n            message: \"initialSupply must be a numeric string representing the amount in wei (18 decimals)\",\n        })\n        .describe(\"Initial token supply, in wei (e.g. 1000000000000000000000 for 1000 tokens)\"),\n    debug: z.boolean().optional().describe(\"Return verbose error information instead of throwing\"),\n});\n\nexport type Params = z.infer<typeof ParamsSchema>;\n\n/**\n * Load BasicToken contract artifacts from the compiled contracts directory\n * @param log - Logger instance for debugging\n * @returns Contract ABI and bytecode\n */\nasync function loadBasicTokenArtifacts(log: any): Promise<{ abi: any; bytecode: `0x${string}` }> {\n    const projectRoot = path.resolve(__dirname, \"..\", \"..\");\n    \n    // Try multiple candidate paths for the BasicToken artifact\n    const candidatePaths = [\n        // From dist/tools (compiled) - artifacts are in src/contracts\n        path.join(__dirname, \"../src/contracts/artifacts-zk/contracts/BasicToken.sol/BasicToken.json\"),\n        // From src/tools (development) - direct path\n        path.join(projectRoot, \"src/contracts/artifacts-zk/contracts/BasicToken.sol/BasicToken.json\"),\n        // Alternative relative path from project root\n        path.join(__dirname, \"../../src/contracts/artifacts-zk/contracts/BasicToken.sol/BasicToken.json\"),\n    ];\n\n    log.info(\"Attempting to load BasicToken artifacts\");\n\n    for (const artifactPath of candidatePaths) {\n        try {\n            if (fs.existsSync(artifactPath)) {\n                log.info(`Found BasicToken artifact at ${artifactPath}`);\n                const artifactJson = JSON.parse(fs.readFileSync(artifactPath, \"utf-8\"));\n                \n                if (!artifactJson.abi || !artifactJson.bytecode) {\n                    throw new Error(\"Invalid artifact: missing ABI or bytecode\");\n                }\n                \n                log.info(\"Successfully loaded BasicToken artifacts\");\n                \n                return {\n                    abi: artifactJson.abi,\n                    bytecode: artifactJson.bytecode as `0x${string}`,\n                };\n            }\n        } catch (error) {\n            log.warn(`Failed to load artifact from path ${artifactPath}: ${(error as Error).message}`);\n        }\n    }\n\n    throw new Error(`BasicToken artifact not found in any of the candidate paths: ${candidatePaths.join(\", \")}`);\n}\n\n/**\n * Validate environment variables required for deployment\n * @param log - Logger instance\n * @returns Validated environment configuration\n */\nfunction validateEnvironment(log: any): { rpcUrl: string; privateKey: string } {\n    const rpcUrl = process.env.ABSTRACT_RPC_URL || process.env.RPC_URL;\n    const privateKey = process.env.ABSTRACT_PRIVATE_KEY || process.env.PRIVATE_KEY;\n\n    log.info(\"Validating environment variables\");\n\n    if (!rpcUrl) {\n        throw new UserError(\"ABSTRACT_RPC_URL or RPC_URL environment variable is required\");\n    }\n\n    if (!privateKey) {\n        throw new UserError(\"ABSTRACT_PRIVATE_KEY or PRIVATE_KEY environment variable is required\");\n    }\n\n    // Basic validation of private key format\n    if (!privateKey.startsWith(\"0x\") || privateKey.length !== 66) {\n        throw new UserError(\"Invalid private key format. Must be 64 hex characters prefixed with 0x\");\n    }\n\n    return { rpcUrl, privateKey };\n}\n\n/**\n * Deploy BasicToken contract using zksync-ethers in a subprocess to avoid ESM issues\n * @param name - Token name\n * @param symbol - Token symbol\n * @param initialSupply - Initial supply in wei\n * @param log - Logger instance\n * @returns Deployed contract address\n */\nasync function deployBasicToken(\n    name: string,\n    symbol: string,\n    initialSupply: string,\n    log: any\n): Promise<string> {\n    log.info(`Starting BasicToken deployment: ${name} (${symbol})`);\n\n    // Validate environment\n    const { rpcUrl, privateKey } = validateEnvironment(log);\n\n    // Use the working standalone script approach but properly integrated\n    const { execFile } = await import(\"child_process\");\n    \n    // Path resolution for the deployment script\n    // In production: everything is bundled into dist/server.js, so __dirname = dist/\n    // In development: __dirname = src/tools/, but we need to find the actual script location\n    \n    // Try multiple path resolutions to handle both scenarios\n    const possiblePaths = [\n        // Production: from dist/server.js to dist/constants/\n        path.resolve(__dirname, \"constants/deployBasicToken.js\"),\n        // Development fallback: from src/tools to src/constants  \n        path.resolve(__dirname, \"../constants/deployBasicToken.js\"),\n        // Alternative: relative to project root\n        path.resolve(process.cwd(), \"dist/constants/deployBasicToken.js\"),\n        path.resolve(process.cwd(), \"src/constants/deployBasicToken.js\")\n    ];\n    \n    let scriptPath: string | null = null;\n    for (const candidatePath of possiblePaths) {\n        if (fs.existsSync(candidatePath)) {\n            scriptPath = candidatePath;\n            break;\n        }\n    }\n    \n    if (!scriptPath) {\n        const pathList = possiblePaths.map(p => `  - ${p}`).join('\\n');\n        throw new Error(`deployBasicToken.js script not found in any expected location:\\n${pathList}\\nMake sure to run 'npm run build' to copy the script.`);\n    }\n    \n    log.info(`Using script path: ${scriptPath}`);\n    log.info(`Current __dirname: ${__dirname}`);\n    log.info(`Resolved script exists: ${fs.existsSync(scriptPath)}`);\n\n    log.info(\"Deploying using standalone script\");\n\n    const result = await new Promise<{ stdout: string; stderr: string; code: number }>((resolve) => {\n        execFile(\n            \"node\",\n            [scriptPath],\n            {\n                env: {\n                    ...process.env,\n                    ABSTRACT_RPC_URL: rpcUrl,\n                    ABSTRACT_PRIVATE_KEY: privateKey,\n                    TOKEN_NAME: name,\n                    TOKEN_SYMBOL: symbol,\n                    TOKEN_SUPPLY: initialSupply,\n                },\n                                 cwd: process.cwd(),\n                maxBuffer: 1024 * 1024 * 10, // 10MB\n            },\n            (error, stdout, stderr) => {\n                let code = 0;\n                if (error) {\n                    if (typeof (error as any).code === \"number\") code = (error as any).code;\n                    else code = 1;\n                }\n                resolve({\n                    stdout,\n                    stderr,\n                    code,\n                });\n            }\n        );\n    });\n\n    if (result.code !== 0) {\n        const errorMsg = result.stderr.trim() || result.stdout.trim() || \"Deployment failed\";\n        log.error(`Token deployment failed: ${errorMsg}`);\n        throw new UserError(errorMsg);\n    }\n\n    // Parse the console output to extract address\n    const output = result.stdout;\n    const contractMatch = output.match(/BasicToken deployed at:\\s*(0x[a-fA-F0-9]+)/i);\n\n    if (!contractMatch) {\n        throw new Error(\"Failed to parse deployed token address from output\");\n    }\n\n    const contractAddress = contractMatch[1];\n    log.info(`BasicToken deployed successfully at: ${contractAddress}`);\n\n    return contractAddress;\n}\n\n/**\n * Register the ab_deploy_token_erc20 tool with FastMCP.\n * Deploys BasicToken ERC-20 contracts using the proven zksync-ethers method.\n */\nexport function registerAbDeployToken(server: FastMCP) {\n    server.addTool({\n        name: \"ab_deploy_token_erc20\",\n        description: `Deploy an ERC-20 BasicToken to the Abstract network.\n\nPARAMETERS\n- name â€“ token name (e.g. \"DemoToken\")\n- symbol â€“ token symbol/ticker (e.g. \"DMT\")\n- initialSupply â€“ numeric string of total supply in wei (18 decimals)\n\nFLOW\n- Uses proven zksync-ethers deployment method via subprocess\n- Returns the deployed contract address\n\nSECURITY / LIMITATIONS\n- Make sure the deployer wallet (ABSTRACT_PRIVATE_KEY / PRIVATE_KEY) has enough funds on the target network`,\n        parameters: ParamsSchema,\n        annotations: { destructiveHint: true, title: \"Contract Deployment Tool\" },\n        execute: deployTokenToolExecute,\n    });\n}\n\nasync function deployTokenToolExecute(args: Params, { log }: { log: any }): Promise<ContentResult> {\n    log.info(`Starting ERC-20 token deployment via MCP: ${args.name} (${args.symbol})`);\n\n    try {\n        // Deploy the token\n        const contractAddress = await deployBasicToken(\n            args.name,\n            args.symbol,\n            args.initialSupply,\n            log\n        );\n\n        // Calculate human-readable supply (assuming 18 decimals)\n        const humanSupply = (BigInt(args.initialSupply) / BigInt(10**18)).toString();\n\n        log.info(`Token deployment completed successfully: ${contractAddress}`);\n\n        return {\n            content: [\n                {\n                    type: \"text\" as const,\n                    text: `ERC-20 Token Deployed Successfully!\n\n**Contract Details:**\n- **Address:** ${contractAddress}\n- **Name:** ${args.name}\n- **Symbol:** ${args.symbol}\n- **Total Supply:** ${humanSupply} ${args.symbol}\n- **Initial Supply (wei):** ${args.initialSupply}\n\n**Next Steps:**\n- Verify contract on Abstract explorer\n- Add token to wallets using contract address\n- Test token transfers and functionality\n\n**Technical Details:**\n- Network: Abstract\n- Standard: ERC-20\n- Decimals: 18`,\n                },\n            ],\n        };\n    } catch (error: any) {\n        log.error(`Token deployment failed: ${error.message}`);\n\n        // Provide specific error messages for common issues\n        let errorMessage = error.message;\n        if (error.message.includes(\"insufficient funds\")) {\n            errorMessage = \"Insufficient funds in wallet for deployment. Please fund your wallet and try again.\";\n        } else if (error.message.includes(\"network\")) {\n            errorMessage = \"Network connection issue. Please check your RPC URL and try again.\";\n        } else if (error.message.includes(\"private key\")) {\n            errorMessage = \"Invalid private key. Please check your ABSTRACT_PRIVATE_KEY environment variable.\";\n        }\n\n        throw new UserError(errorMessage);\n    }\n} ","import { z } from \"zod\";\nimport { FastMCP, UserError } from \"fastmcp\";\nimport { getPublicClient } from \"../utils/viemClient.js\";\nimport { resolveAddress } from \"../utils/addressHelpers.js\";\nimport { getTokenBySymbol } from \"../constants/tokens.js\";\nimport { formatEther } from \"viem\";\n\n// Minimal ERC-20 ABI fragment\nconst ERC20_ABI = [\n    { type: \"function\", name: \"decimals\", stateMutability: \"view\", inputs: [], outputs: [{ name: \"\", type: \"uint8\" }] },\n    { type: \"function\", name: \"balanceOf\", stateMutability: \"view\", inputs: [{ name: \"owner\", type: \"address\" }], outputs: [{ name: \"\", type: \"uint256\" }] },\n] as const;\n\nconst ParamsSchema = z\n    .object({\n        address: z.string().describe(\"Target wallet (address or ENS) to query\"),\n        tokenAddress: z.string().optional().describe(\"ERC-20 token address\"),\n        tokenSymbol: z.string().optional().describe(\"Token symbol to resolve (e.g. USDC)\")\n    })\n    .refine((data) => !(data.tokenAddress && data.tokenSymbol), {\n        message: \"Provide either tokenAddress or tokenSymbol, not both\",\n    });\n\ntype Params = z.infer<typeof ParamsSchema>;\n\nexport function registerGetBalance(server: FastMCP) {\n    server.addTool({\n        name: \"ab_get_balance\",\n        description: `Fetch the current on-chain balance for a wallet.\n\nCAPABILITIES\nâ€¢ Native ETH balance (default)\nâ€¢ ERC-20 balance via tokenAddress OR well-known tokenSymbol (lookup table)\nâ€¢ ENS name resolution for the target address\n\nEXAMPLES\n1. Native balance â†’ { address: \"vitalik.eth\" }\n2. ERC-20 balance via symbol â†’ { address: \"0x123â€¦\", tokenSymbol: \"USDC\" }\n3. ERC-20 via contract â†’ { address: \"0xabcâ€¦\", tokenAddress: \"0xA0b8â€¦\" }\n\nRETURNS\nâ€¢ Human-readable string (e.g. \"12.3456\")\n\nSECURITY\nâ€¢ Read-only operation, no gas spent; safe to run frequently.`,\n        parameters: ParamsSchema,\n        annotations: { readOnlyHint: true, title: \"Get Balance\" },\n        execute: async (args: Params, { log }) => {\n            log.info(\"Resolving address\", { address: args.address });\n            const target = await resolveAddress(args.address);\n            if (!target) throw new UserError(\"Unable to resolve address\");\n\n            const client = getPublicClient();\n\n            // Determine token context\n            let tokenAddress: `0x${string}` | undefined;\n            let decimals = 18;\n            if (args.tokenAddress || args.tokenSymbol) {\n                if (args.tokenAddress) {\n                    tokenAddress = args.tokenAddress as `0x${string}`;\n                } else if (args.tokenSymbol) {\n                    const t = getTokenBySymbol(args.tokenSymbol);\n                    if (!t) throw new UserError(`Unknown token symbol ${args.tokenSymbol}`);\n                    tokenAddress = t.address;\n                    decimals = t.decimals;\n                }\n            }\n\n            if (!tokenAddress) {\n                // Native balance\n                const balance = await client.getBalance({ address: target });\n                const formatted = formatEther(balance);\n                log.info(\"Retrieved native balance\", { balance: formatted });\n                return formatted;\n            }\n\n            // ERC-20 balance\n            log.info(\"Fetching ERC20 balance\", { tokenAddress });\n            // Fetch decimals dynamically\n            try {\n                decimals = await client.readContract({\n                    address: tokenAddress,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                });\n            } catch {\n                // ignore if fails â€“ fallback\n            }\n\n            const balanceRaw: bigint = await client.readContract({\n                address: tokenAddress,\n                abi: ERC20_ABI,\n                functionName: \"balanceOf\",\n                args: [target],\n            });\n            const formatted = Number(balanceRaw) / 10 ** decimals;\n            log.info(\"ERC20 balance\", { formatted });\n            return formatted.toString();\n        },\n    });\n} ","import { createPublicClient, createWalletClient, http, defineChain } from \"viem\";\nimport type { PublicClient, WalletClient, Chain } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore dotenv types resolution conflict under NodeNext\nimport dotenv from \"dotenv\";\n\n// Load .env file if it exists (optional for development)\ntry {\n    dotenv.config();\n} catch (error) {\n    // .env file is optional - all required variables should come from client\n}\n\n// ---------- Chain Definitions ----------\n\nexport const abstractTestnet: Chain = defineChain({\n    id: 11124,\n    name: \"Abstract Testnet\",\n    network: \"abstract-testnet\",\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n    rpcUrls: {\n        default: {\n            http: [process.env.ABSTRACT_RPC_URL ?? \"https://api.testnet.abs.xyz\"],\n        },\n        public: {\n            http: [process.env.ABSTRACT_RPC_URL ?? \"https://api.testnet.abs.xyz\"],\n        },\n    },\n});\n\nexport const abstractMainnet: Chain = defineChain({\n    id: 2741,\n    name: \"Abstract Mainnet\",\n    network: \"abstract-mainnet\",\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n    rpcUrls: {\n        default: {\n            http: [process.env.ABSTRACT_RPC_URL ?? \"https://api.mainnet.abs.xyz/\"],\n        },\n        public: {\n            http: [process.env.ABSTRACT_RPC_URL ?? \"https://api.mainnet.abs.xyz/\"],\n        },\n    },\n});\n\n// Choose chain based on env (default: testnet)\nfunction getChain(): Chain {\n    const target = (process.env.TESTNET ?? \"true\").toLowerCase() === \"true\" ? \"testnet\" : \"mainnet\";\n    return target === \"mainnet\" ? abstractMainnet : abstractTestnet;\n}\n\n// ---------- Singleton Clients ----------\n\nlet _publicClient: PublicClient | undefined;\nlet _walletClient: WalletClient | undefined;\n\nexport function getPublicClient(): PublicClient {\n    if (!_publicClient) {\n        const chain = getChain();\n        _publicClient = createPublicClient({\n            chain,\n            transport: http(chain.rpcUrls.default.http[0]),\n        });\n    }\n    return _publicClient;\n}\n\nexport function getWalletClient(): WalletClient {\n    if (!_walletClient) {\n        let pk = process.env.ABSTRACT_PRIVATE_KEY ?? process.env.PRIVATE_KEY;\n        if (!pk) {\n            throw new Error(\"ABSTRACT_PRIVATE_KEY env variable is required\");\n        }\n        if (!pk.startsWith(\"0x\")) {\n            pk = `0x${pk}`;\n        }\n        const account = privateKeyToAccount(pk as `0x${string}`);\n        const chain = getChain();\n        _walletClient = createWalletClient({\n            chain,\n            transport: http(chain.rpcUrls.default.http[0]),\n            account,\n        });\n    }\n    return _walletClient;\n} ","import { isAddress as _isAddress, namehash } from \"viem\";\nimport { getPublicClient } from \"./viemClient.js\";\n\n/** Check if string is a checksum/hex address */\nexport function isAddress(value: string): boolean {\n    return _isAddress(value);\n}\n\n/**\n * Resolve an ENS name or passthrough an address.\n * Returns undefined if resolution fails.\n */\nexport async function resolveAddress(value: string): Promise<`0x${string}` | undefined> {\n    const client = getPublicClient();\n    if (isAddress(value)) return value as `0x${string}`;\n    try {\n        const address = await client.getEnsAddress({ name: value });\n        return address ?? undefined;\n    } catch {\n        return undefined;\n    }\n} ","export interface TokenInfo {\n    symbol: string;\n    address: `0x${string}`;\n    decimals: number;\n}\n\nexport const TOKENS: TokenInfo[] = [\n    {\n        symbol: \"ETH\",\n        address: \"0x0000000000000000000000000000000000000000\",\n        decimals: 18,\n    },\n    // Add more known tokens here\n];\n\nexport function getTokenBySymbol(symbol: string): TokenInfo | undefined {\n    return TOKENS.find((t) => t.symbol.toLowerCase() === symbol.toLowerCase());\n} ","import { z } from \"zod\";\nimport { FastMCP, UserError } from \"fastmcp\";\nimport { getWalletClient, getPublicClient } from \"../utils/viemClient.js\";\nimport { resolveAddress } from \"../utils/addressHelpers.js\";\nimport { getTokenBySymbol } from \"../constants/tokens.js\";\nimport { parseEther, parseUnits } from \"viem\";\n\nconst ERC20_ABI = [\n    { type: \"function\", name: \"decimals\", stateMutability: \"view\", inputs: [], outputs: [{ type: \"uint8\" }] },\n    { type: \"function\", name: \"transfer\", stateMutability: \"nonpayable\", inputs: [{ name: \"to\", type: \"address\" }, { name: \"amount\", type: \"uint256\" }], outputs: [{ type: \"bool\" }] },\n] as const;\n\nconst ParamsSchema = z\n    .object({\n        to: z.string().describe(\"Recipient address or ENS name\"),\n        amount: z.string().describe(\"Amount to transfer (human units)\"),\n        tokenAddress: z.string().optional(),\n        tokenSymbol: z.string().optional(),\n    })\n    .refine((d) => !(d.tokenAddress && d.tokenSymbol), {\n        message: \"Provide either tokenAddress or tokenSymbol, not both\",\n    });\n\ntype Params = z.infer<typeof ParamsSchema>;\n\nexport function registerTransferToken(server: FastMCP) {\n    server.addTool({\n        name: \"ab_transfer_token\",\n        description: `Transfer value from the callerâ€™s wallet to another address.\n\nFUNCTIONALITY\nâ€¢ Native ETH transfer (simple payment)\nâ€¢ ERC-20 transfer (requires tokenAddress or known tokenSymbol)\nâ€¢ ENS resolution for recipient\n\nVALIDATION & LOGGING\nâ€¢ Ensures wallet signer configured, token decimals fetched automatically\nâ€¢ Logs tx hash on success so the agent can create explorer links\n\nCOMMON USE-CASES\nâ€¢ Payout scripted rewards\nâ€¢ Move workshop faucet tokens to students\nâ€¢ Automation flows needing programmatic payment`,\n        parameters: ParamsSchema,\n        annotations: { destructiveHint: true, title: \"Transfer Token\" },\n        execute: async (args: Params, { log }) => {\n            const recipient = await resolveAddress(args.to);\n            if (!recipient) throw new UserError(\"Unable to resolve recipient\");\n\n            const wallet = getWalletClient();\n            const account = wallet.account;\n            if (!account) throw new UserError(\"Wallet account missing\");\n\n            // Determine token details\n            let tokenAddress: `0x${string}` | undefined;\n            let decimals = 18;\n            if (args.tokenAddress || args.tokenSymbol) {\n                if (args.tokenAddress) {\n                    tokenAddress = args.tokenAddress as `0x${string}`;\n                } else if (args.tokenSymbol) {\n                    const t = getTokenBySymbol(args.tokenSymbol);\n                    if (!t) throw new UserError(`Unknown token symbol ${args.tokenSymbol}`);\n                    tokenAddress = t.address;\n                    decimals = t.decimals;\n                }\n            }\n\n            if (!tokenAddress) {\n                // Native transfer\n                const value = parseEther(args.amount);\n                log.info(\"Sending native ETH\", { to: recipient, value: args.amount });\n                const hash = await wallet.sendTransaction({\n                    to: recipient,\n                    value,\n                    account,\n                    chain: wallet.chain,\n                });\n                log.info(\"Transaction sent\", { hash });\n                return hash;\n            }\n\n            // ERC20 transfer\n            const client = getPublicClient();\n            // Attempt to fetch decimals\n            try {\n                decimals = await client.readContract({\n                    address: tokenAddress,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                });\n            } catch { }\n\n            const amountParsed = parseUnits(args.amount, decimals);\n            log.info(\"Sending ERC20\", { tokenAddress, to: recipient, amount: args.amount });\n            const hash = await wallet.writeContract({\n                address: tokenAddress,\n                abi: ERC20_ABI,\n                functionName: \"transfer\",\n                args: [recipient, amountParsed],\n                account,\n                chain: wallet.chain,\n            });\n            log.info(\"ERC20 transfer tx\", { hash });\n            return hash;\n        },\n    });\n} ","import { z } from \"zod\";\nimport { FastMCP, UserError } from \"fastmcp\";\nimport { deployAccount } from \"@abstract-foundation/agw-client/actions\";\nimport { getWalletClient, getPublicClient } from \"../utils/viemClient.js\";\nimport { resolveAddress } from \"../utils/addressHelpers.js\";\n\nconst ParamsSchema = z.object({\n    signer: z\n        .string()\n        .optional()\n        .describe(\n            \"EOA signer address or ENS. If omitted, uses the server walletâ€™s account as the initial signer\",\n        ),\n});\n\nexport type AgwCreateWalletParams = z.infer<typeof ParamsSchema>;\n\nexport function registerAgwCreateWallet(server: FastMCP) {\n    server.addTool({\n        name: \"ab_agw_create_wallet\",\n        description: `Deploy a new Abstract Global Wallet (smart-contract account) for a given signer.\n\nThe tool wraps @abstract-foundation/agw-clientâ€™s \\`deployAccount\\` helper.\n\nReturns both the smart-account address and the deployment tx hash (\\`undefined\\` when the account already exists).`,\n        parameters: ParamsSchema,\n        annotations: { destructiveHint: true, title: \"AGW â€¢ Deploy Smart Account\" },\n        execute: async (args: AgwCreateWalletParams, { log }) => {\n            const walletClient = getWalletClient() as any; // viem WalletClient\n            const publicClient = getPublicClient() as any; // viem PublicClient\n\n            // Resolve signer if provided\n            let signerAddress: `0x${string}` | undefined = undefined;\n            if (args.signer) {\n                const resolved = await resolveAddress(args.signer);\n                if (!resolved) throw new UserError(\"Unable to resolve signer address\");\n                signerAddress = resolved;\n            }\n\n            log.info(\"Deploying AGW smart account\", { signerAddress: signerAddress ?? walletClient.account.address });\n            const { smartAccountAddress } = await deployAccount({\n                walletClient,\n                publicClient,\n                initialSignerAddress: signerAddress,\n            });\n            return smartAccountAddress;\n        },\n    });\n} ","import {\n  type Account,\n  type Address,\n  encodeFunctionData,\n  type Hash,\n  keccak256,\n  type PublicClient,\n  toBytes,\n  type Transport,\n  type WalletClient,\n  zeroAddress,\n} from 'viem';\nimport type { ChainEIP712, TransactionRequestEIP712 } from 'viem/chains';\n\nimport AccountFactoryAbi from '../abis/AccountFactory.js';\nimport {\n  EOA_VALIDATOR_ADDRESS,\n  SMART_ACCOUNT_FACTORY_ADDRESS,\n} from '../constants.js';\nimport {\n  getInitializerCalldata,\n  getSmartAccountAddressFromInitialSigner,\n  isSmartAccountDeployed,\n} from '../utils.js';\n\nexport type DeployAccountParameters = {\n  walletClient: WalletClient<Transport, ChainEIP712, Account>;\n  publicClient: PublicClient<Transport, ChainEIP712>;\n  initialSignerAddress?: Address;\n} & Omit<TransactionRequestEIP712, 'data' | 'from' | 'to' | 'value' | 'type'>;\n\nexport interface DeployAccountReturnType {\n  smartAccountAddress: Address;\n  deploymentTransaction: Hash | undefined;\n}\n\nexport async function deployAccount(\n  params: DeployAccountParameters,\n): Promise<DeployAccountReturnType> {\n  const { initialSignerAddress, walletClient, publicClient, ...rest } = params;\n\n  const initialSigner = initialSignerAddress ?? walletClient.account.address;\n\n  const address = await getSmartAccountAddressFromInitialSigner(\n    initialSigner,\n    publicClient,\n  );\n\n  let deploymentTransaction: Hash | undefined = undefined;\n\n  const isDeployed = await isSmartAccountDeployed(publicClient, address);\n  if (!isDeployed) {\n    const initializerCallData = getInitializerCalldata(\n      initialSigner,\n      EOA_VALIDATOR_ADDRESS,\n      {\n        allowFailure: false,\n        callData: '0x',\n        value: 0n,\n        target: zeroAddress,\n      },\n    );\n    const addressBytes = toBytes(initialSigner);\n    const salt = keccak256(addressBytes);\n    const deploymentCalldata = encodeFunctionData({\n      abi: AccountFactoryAbi,\n      functionName: 'deployAccount',\n      args: [salt, initializerCallData],\n    });\n\n    deploymentTransaction = await walletClient.sendTransaction({\n      account: walletClient.account,\n      to: SMART_ACCOUNT_FACTORY_ADDRESS,\n      data: deploymentCalldata,\n      ...rest,\n    });\n  }\n\n  return {\n    smartAccountAddress: address,\n    deploymentTransaction,\n  };\n}\n","const AccountFactoryAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_implementation',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes4',\n        name: '_initializerSelector',\n        type: 'bytes4',\n      },\n      {\n        internalType: 'address',\n        name: '_registry',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_proxyBytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'address',\n        name: '_deployer',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_owner',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    inputs: [],\n    name: 'ALREADY_CREATED',\n    type: 'error',\n  },\n  {\n    inputs: [],\n    name: 'DEPLOYMENT_FAILED',\n    type: 'error',\n  },\n  {\n    inputs: [],\n    name: 'INVALID_INITIALIZER',\n    type: 'error',\n  },\n  {\n    inputs: [],\n    name: 'NOT_FROM_DEPLOYER',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'owner',\n        type: 'address',\n      },\n    ],\n    name: 'OwnableInvalidOwner',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'OwnableUnauthorizedAccount',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    name: 'AGWAccountCreated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    name: 'AGWAccountDeployed',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'deployer',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'bool',\n        name: 'authorized',\n        type: 'bool',\n      },\n    ],\n    name: 'DeployerAuthorized',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newImplementation',\n        type: 'address',\n      },\n    ],\n    name: 'ImplementationChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'previousOwner',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    name: 'OwnershipTransferStarted',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'previousOwner',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    name: 'OwnershipTransferred',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newRegistry',\n        type: 'address',\n      },\n    ],\n    name: 'RegistryChanged',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'acceptOwnership',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'accountToDeployer',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'deployer',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    name: 'agwAccountCreated',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'deployer',\n        type: 'address',\n      },\n    ],\n    name: 'authorizedDeployers',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: 'authorized',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newImplementation',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes4',\n        name: 'newInitializerSelector',\n        type: 'bytes4',\n      },\n    ],\n    name: 'changeImplementation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newRegistry',\n        type: 'address',\n      },\n    ],\n    name: 'changeRegistry',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: 'initializer',\n        type: 'bytes',\n      },\n    ],\n    name: 'deployAccount',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'salt',\n        type: 'bytes32',\n      },\n    ],\n    name: 'getAddressForSalt',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'address',\n        name: '_implementation',\n        type: 'address',\n      },\n    ],\n    name: 'getAddressForSaltAndImplementation',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'implementationAddress',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'initializerSelector',\n    outputs: [\n      {\n        internalType: 'bytes4',\n        name: '',\n        type: 'bytes4',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'owner',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'pendingOwner',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'proxyBytecodeHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'registry',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'renounceOwnership',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'salt',\n        type: 'bytes32',\n      },\n    ],\n    name: 'saltToAccount',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'deployer',\n        type: 'address',\n      },\n      {\n        internalType: 'bool',\n        name: 'authorized',\n        type: 'bool',\n      },\n    ],\n    name: 'setDeployer',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    name: 'transferOwnership',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n\nexport default AccountFactoryAbi;\n","import type { Address } from 'viem';\nimport { abstract, abstractTestnet } from 'viem/chains';\n\n// AA smart contract deployment\nconst SMART_ACCOUNT_FACTORY_ADDRESS =\n  '0x9B947df68D35281C972511B3E7BC875926f26C1A' as const;\n\n// AA wallet validator contract deployment\nconst EOA_VALIDATOR_ADDRESS = '0x74b9ae28EC45E3FA11533c7954752597C3De3e7A';\n\nconst SESSION_KEY_VALIDATOR_ADDRESS =\n  '0x34ca1501FAE231cC2ebc995CE013Dbe882d7d081';\n\nconst CONTRACT_DEPLOYER_ADDRESS =\n  '0x0000000000000000000000000000000000008006' as const;\n\nconst AGW_REGISTRY_ADDRESS =\n  '0xd5E3efDA6bB5aB545cc2358796E96D9033496Dda' as const;\n\n/** `function addModule(bytes moduleAndData) external` */\nconst ADD_MODULE_SELECTOR = '0xd3bdf4b5' as const;\n\n/** `function createSession(SessionLib.SessionSpec memory sessionSpec) external` */\nconst CREATE_SESSION_SELECTOR = '0x5a0694d2' as const;\n\n/** `function batchCall((address,bool,uint256,bytes)[]) external` */\nconst BATCH_CALL_SELECTOR = '0x8f0273a9' as const;\n\n/** `error INSUFFICIENT_FUNDS()` */\nconst INSUFFICIENT_BALANCE_SELECTOR = '0xe7931438' as const;\n\nconst CANONICAL_DELEGATE_REGISTRY_ADDRESS =\n  '0x0000000059A24EB229eED07Ac44229DB56C5d797';\n\nconst CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS =\n  '0x0000000078CC4Cc1C14E27c0fa35ED6E5E58825D';\n\nconst AGW_LINK_DELEGATION_RIGHTS =\n  '0xc10dcfe266c1f71ef476efbd3223555750dc271e4115626b';\n\nconst NON_EXPIRING_DELEGATION_RIGHTS = `${AGW_LINK_DELEGATION_RIGHTS}000000ffffffffff`;\n\nconst BASE_GAS_PER_PUBDATA_BYTE = 800n;\n\nconst BRIDGEHUB_ADDRESS: Record<number, Address> = {\n  [abstractTestnet.id]: '0x35A54c8C757806eB6820629bc82d90E056394C92',\n  [abstract.id]: '0x303a465b659cbb0ab36ee643ea362c509eeb5213',\n};\n\nconst SESSION_KEY_POLICY_REGISTRY_ADDRESS: Address =\n  '0xfD20b9d7A406e2C4f5D6Df71ABE3Ee48B2EccC9F';\n\nconst FEATURE_FLAG_REGISTRY_ADDRESS: Address =\n  '0xb5023a9F3e948e3A4f9DBA97118EEE801fA4e265';\n\nexport {\n  ADD_MODULE_SELECTOR,\n  AGW_LINK_DELEGATION_RIGHTS,\n  AGW_REGISTRY_ADDRESS,\n  BASE_GAS_PER_PUBDATA_BYTE,\n  BATCH_CALL_SELECTOR,\n  BRIDGEHUB_ADDRESS,\n  CANONICAL_DELEGATE_REGISTRY_ADDRESS,\n  CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,\n  CONTRACT_DEPLOYER_ADDRESS,\n  CREATE_SESSION_SELECTOR,\n  EOA_VALIDATOR_ADDRESS,\n  FEATURE_FLAG_REGISTRY_ADDRESS,\n  INSUFFICIENT_BALANCE_SELECTOR,\n  NON_EXPIRING_DELEGATION_RIGHTS,\n  SESSION_KEY_POLICY_REGISTRY_ADDRESS,\n  SESSION_KEY_VALIDATOR_ADDRESS,\n  SMART_ACCOUNT_FACTORY_ADDRESS,\n};\n","import {\n  type Address,\n  BaseError,\n  type Chain,\n  encodeFunctionData,\n  fromHex,\n  type Hex,\n  isHex,\n  keccak256,\n  type PublicClient,\n  toBytes,\n  toHex,\n  type Transport,\n  type TypedDataDefinition,\n  type UnionRequiredBy,\n} from 'viem';\nimport { parseAccount } from 'viem/accounts';\nimport { abstract, abstractTestnet } from 'viem/chains';\nimport {\n  type ChainEIP712,\n  type SignEip712TransactionParameters,\n} from 'viem/zksync';\n\nimport AccountFactoryAbi from './abis/AccountFactory.js';\nimport { AGWRegistryAbi } from './abis/AGWRegistryAbi.js';\nimport {\n  AGW_REGISTRY_ADDRESS,\n  SMART_ACCOUNT_FACTORY_ADDRESS,\n} from './constants.js';\nimport { isEIP712Transaction } from './eip712.js';\nimport { type Call } from './types/call.js';\n\nexport const VALID_CHAINS: Record<number, Chain> = {\n  [abstractTestnet.id]: abstractTestnet,\n  [abstract.id]: abstract,\n};\n\nexport function convertBigIntToString(value: any): any {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return value.map(convertBigIntToString);\n  } else if (typeof value === 'object' && value !== null) {\n    return Object.fromEntries(\n      Object.entries(value).map(([key, val]) => [\n        key,\n        convertBigIntToString(val),\n      ]),\n    );\n  }\n  return value;\n}\n\nexport async function getSmartAccountAddressFromInitialSigner<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  initialSigner: Address,\n  publicClient: PublicClient<Transport, chain>,\n): Promise<Hex> {\n  if (initialSigner === undefined) {\n    throw new Error('Initial signer is required to get smart account address');\n  }\n  // Generate salt based off address\n  const addressBytes = toBytes(initialSigner);\n  const salt = keccak256(addressBytes);\n\n  // Get the deployed account address\n  const accountAddress = (await publicClient.readContract({\n    address: SMART_ACCOUNT_FACTORY_ADDRESS,\n    abi: AccountFactoryAbi,\n    functionName: 'getAddressForSalt',\n    args: [salt],\n  })) as Hex;\n\n  return accountAddress;\n}\n\nexport async function isAGWAccount<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  publicClient: PublicClient<Transport, chain>,\n  address: Address,\n): Promise<boolean> {\n  return await publicClient.readContract({\n    address: AGW_REGISTRY_ADDRESS,\n    abi: AGWRegistryAbi,\n    functionName: 'isAGW',\n    args: [address],\n  });\n}\n\nexport async function isSmartAccountDeployed<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  publicClient: PublicClient<Transport, chain>,\n  address: Hex,\n): Promise<boolean> {\n  const bytecode = await publicClient.getCode({\n    address: address,\n  });\n  return bytecode !== undefined;\n}\n\nexport function getInitializerCalldata(\n  initialOwnerAddress: Address,\n  validatorAddress: Address,\n  initialCall: Call,\n): Hex {\n  return encodeFunctionData({\n    abi: [\n      {\n        name: 'initialize',\n        type: 'function',\n        inputs: [\n          { name: 'initialK1Owner', type: 'address' },\n          { name: 'initialK1Validator', type: 'address' },\n          { name: 'modules', type: 'bytes[]' },\n          {\n            name: 'initCall',\n            type: 'tuple',\n            components: [\n              { name: 'target', type: 'address' },\n              { name: 'allowFailure', type: 'bool' },\n              { name: 'value', type: 'uint256' },\n              { name: 'callData', type: 'bytes' },\n            ],\n          },\n        ],\n        outputs: [],\n        stateMutability: 'nonpayable',\n      },\n    ],\n    functionName: 'initialize',\n    args: [initialOwnerAddress, validatorAddress, [], initialCall],\n  });\n}\n\nexport function transformHexValues(transaction: any, keys: string[]) {\n  if (!transaction) return;\n  for (const key of keys) {\n    if (isHex(transaction[key])) {\n      transaction[key] = fromHex(transaction[key], 'bigint');\n    }\n  }\n}\n\nexport function isEip712TypedData(typedData: TypedDataDefinition): boolean {\n  return (\n    typedData.message &&\n    typedData.domain?.name === 'zkSync' &&\n    typedData.domain?.version === '2' &&\n    isEIP712Transaction(typedData.message)\n  );\n}\n\nexport function transformEip712TypedData(\n  typedData: TypedDataDefinition,\n): UnionRequiredBy<\n  Omit<SignEip712TransactionParameters, 'chain'>,\n  'to' | 'data'\n> & { chainId: number } {\n  if (!isEip712TypedData(typedData)) {\n    throw new BaseError('Typed data is not an EIP712 transaction');\n  }\n\n  if (typedData.domain?.chainId === undefined) {\n    throw new BaseError('Chain ID is required for EIP712 transaction');\n  }\n\n  return {\n    chainId: Number(typedData.domain.chainId),\n    account: parseAccount(\n      toHex(BigInt(typedData.message['from'] as string), {\n        size: 20,\n      }),\n    ),\n    to: toHex(BigInt(typedData.message['to'] as string), {\n      size: 20,\n    }),\n    gas: BigInt(typedData.message['gasLimit'] as string),\n    gasPerPubdata: BigInt(\n      typedData.message['gasPerPubdataByteLimit'] as string,\n    ),\n    maxFeePerGas: BigInt(typedData.message['maxFeePerGas'] as string),\n    maxPriorityFeePerGas: BigInt(\n      typedData.message['maxPriorityFeePerGas'] as string,\n    ),\n    paymaster:\n      (typedData.message['paymaster'] as string) != '0'\n        ? toHex(BigInt(typedData.message['paymaster'] as string), {\n            size: 20,\n          })\n        : undefined,\n    nonce: typedData.message['nonce'] as number,\n    value: BigInt(typedData.message['value'] as string),\n    data:\n      typedData.message['data'] === '0x0'\n        ? '0x'\n        : (typedData.message['data'] as Hex),\n    factoryDeps: typedData.message['factoryDeps'] as Hex[],\n    paymasterInput:\n      typedData.message['paymasterInput'] !== '0x'\n        ? (typedData.message['paymasterInput'] as Hex)\n        : undefined,\n  };\n}\n","import { type ExactPartial, type OneOf } from 'viem';\nimport { assertRequest } from 'viem/utils';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type ZksyncTransactionRequest,\n  type ZksyncTransactionSerializable,\n} from 'viem/zksync';\n\nimport { InvalidEip712TransactionError } from './errors/eip712.js';\n\nexport type AssertEip712RequestParameters = ExactPartial<\n  SendEip712TransactionParameters<ChainEIP712>\n>;\n\nexport function isEIP712Transaction(\n  transaction: ExactPartial<\n    OneOf<ZksyncTransactionRequest | ZksyncTransactionSerializable>\n  >,\n) {\n  if (transaction.type === 'eip712') return true;\n  if (\n    ('customSignature' in transaction && transaction.customSignature) ||\n    ('paymaster' in transaction && transaction.paymaster) ||\n    ('paymasterInput' in transaction && transaction.paymasterInput) ||\n    ('gasPerPubdata' in transaction &&\n      typeof transaction.gasPerPubdata === 'bigint') ||\n    ('factoryDeps' in transaction && transaction.factoryDeps)\n  )\n    return true;\n  return false;\n}\n\nexport function assertEip712Request(args: AssertEip712RequestParameters) {\n  if (!isEIP712Transaction(args as any))\n    throw new InvalidEip712TransactionError();\n  assertRequest(args as any);\n}\n","import { BaseError } from 'viem';\n\nexport class InvalidEip712TransactionError extends BaseError {\n  constructor() {\n    super(\n      [\n        'Transaction is not an EIP712 transaction.',\n        '',\n        'Transaction must:',\n        '  - include `type: \"eip712\"`',\n        '  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`',\n      ].join('\\n'),\n      { name: 'InvalidEip712TransactionError' },\n    );\n  }\n}\n","import { type Address, type Hex } from 'viem';\n\nexport interface Call {\n  target: Address;\n  allowFailure: boolean;\n  value: bigint;\n  callData: Hex;\n}\n","import {\n  type Account,\n  type Address,\n  checksumAddress,\n  type Client,\n  getAddress,\n  InvalidAddressError,\n  isAddress,\n  type Transport,\n} from 'viem';\nimport { readContract } from 'viem/actions';\nimport { getAction, parseAccount } from 'viem/utils';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport { ExclusiveDelegateResolverAbi } from '../abis/ExclusiveDelegateResolver.js';\nimport {\n  AGW_LINK_DELEGATION_RIGHTS,\n  CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,\n} from '../constants.js';\nimport { AccountNotFoundError } from '../errors/account.js';\n\nexport interface GetLinkedAccountsReturnType {\n  linkedAccounts: Address[];\n}\n\nexport interface GetLinkedAccountsParameters {\n  agwAddress: Address;\n}\n\nexport interface IsLinkedAccountParameters {\n  address: Address;\n}\n\n/**\n * Get all accounts linked to an Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n *\n * export default function LinkedAccounts() {\n *     const { data: agwClient } = useAbstractClient();\n *\n *     async function fetchLinkedAccounts() {\n *         if (!agwClient) return;\n *\n *         const { linkedAccounts } = await agwClient.getLinkedAccounts({\n *             agwAddress: agwClient.account.address\n *         });\n *\n *         console.log(linkedAccounts); // Array of linked account addresses\n *     }\n * }\n * ```\n *\n * @param parameters - Parameters for getting linked accounts\n * @param parameters.agwAddress - Address of the Abstract Global Wallet to check for linked accounts (required)\n * @returns An object containing an array of linked account addresses\n */\nexport async function getLinkedAccounts<\n  transport extends Transport = Transport,\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  client: Client<transport, chain, account>,\n  parameters: GetLinkedAccountsParameters,\n): Promise<GetLinkedAccountsReturnType> {\n  const { agwAddress } = parameters;\n\n  if (!isAddress(agwAddress, { strict: false })) {\n    throw new InvalidAddressError({ address: agwAddress });\n  }\n\n  const checksummedAddress = getAddress(agwAddress);\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    abi: ExclusiveDelegateResolverAbi,\n    address: CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,\n    functionName: 'delegatedWalletsByRights',\n    args: [checksummedAddress, AGW_LINK_DELEGATION_RIGHTS],\n  });\n\n  return {\n    linkedAccounts: [...result],\n  };\n}\n\n/**\n * Check if an address is linked to the connected Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n *\n * export default function CheckLinkedAccount() {\n *     const { data: agwClient } = useAbstractClient();\n *     const addressToCheck = \"0x...\";\n *\n *     async function checkIfLinked() {\n *         if (!agwClient) return;\n *\n *         const isLinked = await agwClient.isLinkedAccount({\n *             address: addressToCheck\n *         });\n *\n *         console.log(isLinked); // true or false\n *     }\n * }\n * ```\n *\n * @param parameters - Parameters for checking linked account\n * @param parameters.address - Address to check if linked to the connected wallet (required)\n * @returns Boolean indicating if the address is linked to the connected wallet\n */\nexport async function isLinkedAccount(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters: IsLinkedAccountParameters,\n): Promise<boolean> {\n  const { address } = parameters;\n  if (!client.account) {\n    throw new AccountNotFoundError({\n      docsPath: '/docs/contract/readContract',\n    });\n  }\n  const clientAccount = parseAccount(client.account);\n  const { linkedAccounts } = await getLinkedAccounts(client, {\n    agwAddress: clientAccount.address,\n  });\n\n  return linkedAccounts.includes(checksumAddress(address));\n}\n","import { BaseError } from 'viem';\n\nexport class AccountNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\n    super(\n      [\n        'Could not find an Account to execute with this Action.',\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\n      ].join('\\n'),\n      {\n        docsPath,\n        docsSlug: 'account',\n        name: 'AccountNotFoundError',\n      },\n    );\n  }\n}\n","import {\n  type Account,\n  type Address,\n  BaseError,\n  type Chain,\n  type Client,\n  getAddress,\n  InvalidAddressError,\n  isAddress,\n  type Transport,\n} from 'viem';\nimport { readContract } from 'viem/actions';\nimport { getAction, parseAccount } from 'viem/utils';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport { ExclusiveDelegateResolverAbi } from '../abis/ExclusiveDelegateResolver.js';\nimport {\n  AGW_LINK_DELEGATION_RIGHTS,\n  CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,\n} from '../constants.js';\nimport { AccountNotFoundError } from '../errors/account.js';\n\nexport interface GetLinkedAgwReturnType {\n  agw: Address | undefined;\n}\n\nexport interface GetLinkedAgwParameters {\n  address?: Address | undefined;\n}\n\nexport interface IsLinkedAccountParameters {\n  address: Address;\n}\n\n/**\n * Get the linked Abstract Global Wallet for an Ethereum Mainnet address.\n *\n * @example\n * ```tsx\n * import { linkableWalletActions } from \"@abstract-foundation/agw-client\";\n * import { createWalletClient, custom } from \"viem\";\n * import { sepolia } from \"viem/chains\";\n *\n * export default function CheckLinkedWallet() {\n *   async function checkLinkedWallet() {\n *     // Initialize a Viem Wallet client and extend it with linkableWalletActions\n *     const client = createWalletClient({\n *       chain: sepolia,\n *       transport: custom(window.ethereum!),\n *     }).extend(linkableWalletActions());\n *\n *     // Check if an address has a linked AGW\n *     const { agw } = await client.getLinkedAgw();\n *\n *     if (agw) {\n *       console.log(\"Linked AGW:\", agw);\n *     } else {\n *       console.log(\"No linked AGW found\");\n *     }\n *   }\n *\n *   return <button onClick={checkLinkedWallet}>Check Linked AGW</button>;\n * }\n * ```\n *\n * @param parameters - Parameters for getting the linked AGW\n * @param parameters.address - The Ethereum Mainnet address to check for a linked AGW. If not provided, defaults to the connected account's address\n * @returns Object containing the address of the linked AGW, or undefined if no AGW is linked\n */\nexport async function getLinkedAgw<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetLinkedAgwParameters,\n): Promise<GetLinkedAgwReturnType> {\n  const { address = client.account?.address } = parameters;\n\n  if (address === undefined) {\n    throw new BaseError('No address provided');\n  }\n\n  if (!isAddress(address, { strict: false })) {\n    throw new InvalidAddressError({ address });\n  }\n\n  const checksummedAddress = getAddress(address);\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    abi: ExclusiveDelegateResolverAbi,\n    address: CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,\n    functionName: 'exclusiveWalletByRights',\n    args: [checksummedAddress, AGW_LINK_DELEGATION_RIGHTS],\n  });\n\n  if (result === checksummedAddress) {\n    return {\n      agw: undefined,\n    };\n  }\n\n  return {\n    agw: result,\n  };\n}\n\nexport async function isLinkedAccount(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters: IsLinkedAccountParameters,\n): Promise<boolean> {\n  const { address } = parameters;\n\n  if (client.account === undefined) {\n    throw new AccountNotFoundError({\n      docsPath: '/docs/contract/readContract',\n    });\n  }\n\n  const clientAccount = parseAccount(client.account);\n\n  const { agw } = await getLinkedAgw(client, { address });\n  return agw === clientAccount.address;\n}\n","import {\n  type Address,\n  encodeAbiParameters,\n  getAbiItem,\n  getAddress,\n  type Hash,\n  type Hex,\n  keccak256,\n} from 'viem';\n\nimport { SessionKeyValidatorAbi } from './abis/SessionKeyValidator.js';\n\nexport enum LimitType {\n  Unlimited = 0,\n  Lifetime = 1,\n  Allowance = 2,\n}\n\n/**\n * Limit is the value tracked either for a lifetime or a period on-chain\n * @member limitType - Used to validate limit & period values (unlimited has no limit, lifetime has no period, allowance has both!)\n * @member limit - The limit is exceeded if the tracked value is greater than this over the provided period\n * @member period - The block.timestamp divisor for the limit to be enforced (eg: 60 for a minute, 86400 for a day, 604800 for a week, unset for lifetime)\n */\nexport interface Limit {\n  limitType: LimitType;\n  limit: bigint;\n  period: bigint;\n}\n\nexport const LimitUnlimited = {\n  limitType: LimitType.Unlimited,\n  limit: 0n,\n  period: 0n,\n};\n\nexport const LimitZero = {\n  limitType: LimitType.Lifetime,\n  limit: 0n,\n  period: 0n,\n};\n\n/**\n * Common logic operators to used combine multiple constraints\n */\nexport enum ConstraintCondition {\n  Unconstrained = 0,\n  Equal = 1,\n  Greater = 2,\n  Less = 3,\n  GreaterEqual = 4,\n  LessEqual = 5,\n  NotEqual = 6,\n}\n\n/**\n * Constraint allows performing logic checks on any binary word (bytes32) in the transaction.\n * This can let you set spend limits against functions on specific contracts\n * @member index - The location of the start of the data in the transaction. This is not the index of the constraint within the containing array!\n * @member condition - The kind of check to perform (None, =, >, <, >=, <=, !=)\n * @member refValue - The value to compare against (as bytes32)\n * @member limit - The limit to enforce on the parsed value (from index)\n */\nexport interface Constraint {\n  index: bigint;\n  condition: ConstraintCondition;\n  refValue: Hash;\n  limit: Limit;\n}\n\n/**\n * CallPolicy is a policy for a specific contract (address/function) call.\n * @member target - Only one policy per target per session (unique mapping)\n * @member selector - Solidity function selector (the selector directly), also unique mapping with target\n * @member maxValuePerUse - Will reject transaction if value is set above this amount (for transfer or call)\n * @member valueLimit - If not set, unlimited. If a number or a limit without a period, converts to a lifetime value. Also rejects transactions that have cumulative value greater than what's set here\n * @member constraints - Array of conditions with specific limits for performing range and logic checks (e.g. 5 > x >= 30) on the transaction data (not value!)\n */\nexport interface CallPolicy {\n  target: Address;\n  valueLimit: Limit;\n  maxValuePerUse: bigint;\n  selector: Hash;\n  constraints: Constraint[];\n}\n\n/**\n * Simplified CallPolicy for transactions with less than 4 bytes of data\n * @member target - Only one policy per target per session (unique mapping from CallPolicies)\n * @member maxValuePerUse - Will reject transaction if value is set above this amount\n * @member valueLimit - Validated from value\n */\nexport interface TransferPolicy {\n  target: Address;\n  maxValuePerUse: bigint;\n  valueLimit: Limit;\n}\n\n/**\n * SessionConfig is a set of policies and metadata to validate a transaction\n * @member signer - The address that signs the transaction (session public key)\n * @member expiresAt - The block.timestamp at which the session is no longer valid\n * @member feeLimit - The maximum fee that can be paid for the transaction (maxFeePerGas * gasLimit)\n * @member callPolicies - Used to validate the transaction data, has complex calldata parsing logic\n * @member transferPolicies - Used to validate the transaction value when there's no additional data\n */\nexport interface SessionConfig {\n  signer: Address;\n  expiresAt: bigint;\n  feeLimit: Limit;\n  callPolicies: CallPolicy[];\n  transferPolicies: TransferPolicy[];\n}\n\nexport enum SessionStatus {\n  NotInitialized = 0,\n  Active = 1,\n  Closed = 2,\n  Expired = 3,\n}\n\nexport interface SessionState {\n  expiresAt: bigint;\n  status: SessionStatus;\n  feesRemaining: bigint;\n  transferValue: {\n    remaining: bigint;\n    target: Address;\n    selector: Hash;\n    index: bigint;\n  }[];\n  callValue: {\n    remaining: bigint;\n    target: Address;\n    selector: Hash;\n    index: bigint;\n  }[];\n  callParams: {\n    remaining: bigint;\n    target: Address;\n    selector: Hash;\n    index: bigint;\n  }[];\n}\n\nexport function getSessionSpec() {\n  return getAbiItem({\n    abi: SessionKeyValidatorAbi,\n    name: 'createSession',\n  }).inputs[0];\n}\n\nexport function encodeSession(sessionConfig: SessionConfig): Hex {\n  return encodeAbiParameters([getSessionSpec()], [sessionConfig]);\n}\n\nexport function encodeSessionWithPeriodIds(\n  sessionConfig: SessionConfig,\n  periods: bigint[],\n): Hex {\n  return encodeAbiParameters(\n    [getSessionSpec(), { type: 'uint64[]' }],\n    [sessionConfig, periods],\n  );\n}\n\nexport const getPeriodIdsForTransaction = (args: {\n  sessionConfig: SessionConfig;\n  target: Address;\n  selector?: Hex;\n  timestamp?: bigint;\n}) => {\n  const timestamp = args.timestamp || BigInt(Math.floor(Date.now() / 1000));\n  const target = getAddress(args.target);\n\n  const getId = (limit: Limit): bigint => {\n    if (limit.limitType === LimitType.Allowance) {\n      return timestamp / limit.period;\n    }\n    return 0n;\n  };\n\n  const findTransferPolicy = () => {\n    return args.sessionConfig.transferPolicies.find(\n      (policy) => policy.target.toLowerCase() === target.toLowerCase(),\n    );\n  };\n  const findCallPolicy = () => {\n    return args.sessionConfig.callPolicies.find(\n      (policy) =>\n        policy.target.toLowerCase() === target.toLowerCase() &&\n        policy.selector == args.selector,\n    );\n  };\n\n  const isContractCall = !!args.selector && args.selector.length >= 10;\n  const policy: TransferPolicy | CallPolicy | undefined = isContractCall\n    ? findCallPolicy()\n    : findTransferPolicy();\n  if (!policy) throw new Error('Transaction does not fit any policy');\n\n  const periodIds = [\n    getId(args.sessionConfig.feeLimit),\n    getId(policy.valueLimit),\n    ...(isContractCall\n      ? (policy as CallPolicy).constraints.map((constraint) =>\n          getId(constraint.limit),\n        )\n      : []),\n  ];\n  return periodIds;\n};\n\nexport function getSessionHash(sessionConfig: SessionConfig): Hash {\n  return keccak256(encodeSession(sessionConfig));\n}\n","import { BaseError } from 'abitype';\nimport {\n  type Account,\n  type Address,\n  type Chain,\n  createPublicClient,\n  decodeEventLog,\n  encodeFunctionData,\n  type Hash,\n  http,\n  type PublicClient,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport { writeContract } from 'viem/actions';\nimport { getAction, parseAccount } from 'viem/utils';\nimport { publicActionsL2 } from 'viem/zksync';\n\nimport { BridgeHubAbi } from '../abis/BridgeHubAbi.js';\nimport { DelegateRegistryAbi } from '../abis/DelegateRegistry.js';\nimport { ZkSyncAbi } from '../abis/ZkSyncAbi.js';\nimport {\n  BASE_GAS_PER_PUBDATA_BYTE,\n  BRIDGEHUB_ADDRESS,\n  CANONICAL_DELEGATE_REGISTRY_ADDRESS,\n  NON_EXPIRING_DELEGATION_RIGHTS,\n} from '../constants.js';\nimport { AccountNotFoundError } from '../errors/account.js';\nimport { VALID_CHAINS } from '../utils.js';\n\nexport interface LinkToAgwParameters {\n  agwAddress: Address;\n  enabled: boolean;\n  l2Chain: Chain;\n  account?: Account;\n}\n\nexport interface LinkToAgwReturnType {\n  l1TransactionHash: Hash;\n  getL2TransactionHash: () => Promise<Hash>;\n}\n\n/**\n * Function to link an Ethereum Mainnet wallet to an Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { linkableWalletActions } from \"@abstract-foundation/agw-client\";\n * import { createWalletClient, custom } from \"viem\";\n * import { sepolia, abstractTestnet } from \"viem/chains\";\n *\n * export default function LinkWallet() {\n *   async function linkAgwWallet() {\n *     // Initialize a Viem Wallet client and extend it with linkableWalletActions\n *     const client = createWalletClient({\n *       chain: sepolia,\n *       transport: custom(window.ethereum!),\n *     }).extend(linkableWalletActions());\n *\n *     // Call linkToAgw with the AGW address\n *     const { l1TransactionHash, getL2TransactionHash } =\n *       await client.linkToAgw({\n *         agwAddress: \"0x...\", // The AGW address to link to\n *         enabled: true, // Enable or disable the link\n *         l2Chain: abstractTestnet,\n *       });\n *\n *     // Get the L2 transaction hash once the L1 transaction is confirmed\n *     const l2Hash = await getL2TransactionHash();\n *   }\n *\n *   return <button onClick={linkAgwWallet}>Link Wallet</button>;\n * }\n * ```\n *\n * @param parameters - Parameters for linking a wallet\n * @param parameters.agwAddress - The address of the Abstract Global Wallet to link to (required)\n * @param parameters.enabled - Whether to enable or disable the link between the wallets (required)\n * @param parameters.l2Chain - The Abstract chain to create the link on (e.g. abstractTestnet) (required)\n * @param parameters.account - The account to use for the transaction\n * @returns Object containing the L1 transaction hash and a function to get the L2 transaction hash\n * @returns.l1TransactionHash - The transaction hash of the L1 transaction that initiated the link\n * @returns.getL2TransactionHash - A function that returns a Promise resolving to the L2 transaction hash once the L1 transaction is confirmed\n */\nexport async function linkToAgw<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  client: WalletClient<transport, chain, account>,\n  parameters: LinkToAgwParameters,\n): Promise<LinkToAgwReturnType> {\n  const {\n    account: account_ = client.account,\n    agwAddress,\n    enabled,\n    l2Chain,\n  } = parameters;\n\n  if (!account_) {\n    throw new AccountNotFoundError();\n  }\n  const account = parseAccount(account_);\n\n  if (!VALID_CHAINS[l2Chain.id]) {\n    throw new BaseError('Unsupported L2 Chain');\n  }\n\n  const bridgehubAddress = BRIDGEHUB_ADDRESS[l2Chain.id] as Address;\n\n  const l1PublicClient = createPublicClient({\n    chain: client.chain,\n    transport: http(),\n  });\n\n  const l2PublicClient = createPublicClient({\n    chain: l2Chain,\n    transport: http(),\n  }).extend(publicActionsL2());\n\n  const l2Value = 0n;\n  const operatorTip = 0n;\n\n  const l2Calldata = encodeFunctionData({\n    abi: DelegateRegistryAbi,\n    functionName: 'delegateAll',\n    args: [agwAddress, NON_EXPIRING_DELEGATION_RIGHTS, enabled],\n  });\n\n  const l2GasLimit = await l2PublicClient.estimateGasL1ToL2({\n    chain: l2PublicClient.chain,\n    account: account.address,\n    to: CANONICAL_DELEGATE_REGISTRY_ADDRESS,\n    data: l2Calldata,\n    value: 0n,\n  });\n\n  const baseFee = await l1PublicClient.getGasPrice();\n  const maxPriorityFeePerGas =\n    await l1PublicClient.estimateMaxPriorityFeePerGas();\n  const maxFeePerGas = (baseFee * 3n) / 2n + maxPriorityFeePerGas;\n  const gasPriceForEstimation = maxFeePerGas;\n\n  const baseCost = await l1PublicClient.readContract({\n    address: bridgehubAddress,\n    abi: BridgeHubAbi,\n    functionName: 'l2TransactionBaseCost',\n    args: [\n      BigInt(l2PublicClient.chain.id),\n      gasPriceForEstimation,\n      l2GasLimit,\n      BASE_GAS_PER_PUBDATA_BYTE,\n    ],\n  });\n\n  const l2Costs = baseCost + operatorTip + l2Value;\n  const providedValue = l2Costs;\n\n  if (baseCost > providedValue) {\n    console.error('Base cost is greater than provided value');\n  }\n\n  const bridgeArgs = {\n    chainId: BigInt(l2PublicClient.chain.id),\n    mintValue: providedValue,\n    l2Contract: CANONICAL_DELEGATE_REGISTRY_ADDRESS,\n    l2Value,\n    l2Calldata,\n    l2GasLimit,\n    l2GasPerPubdataByteLimit: BASE_GAS_PER_PUBDATA_BYTE,\n    factoryDeps: [],\n    refundRecipient: agwAddress,\n  } as const;\n\n  const l1TransactionHash = await getAction(\n    client,\n    writeContract,\n    'writeContract',\n  )({\n    abi: BridgeHubAbi,\n    address: bridgehubAddress,\n    chain: client.chain,\n    account,\n    functionName: 'requestL2TransactionDirect',\n    value: providedValue,\n    args: [bridgeArgs],\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  } as any);\n\n  return {\n    l1TransactionHash,\n    getL2TransactionHash: async () =>\n      getL2HashFromPriorityOp(l1PublicClient, l1TransactionHash),\n  };\n}\n\nasync function getL2HashFromPriorityOp<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  publicClient: PublicClient<Transport, chain, account>,\n  l1TransactionHash: Hash,\n): Promise<Hash> {\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash: l1TransactionHash,\n  });\n  if (receipt.status !== 'success') {\n    throw new BaseError('L1 transaction failed');\n  }\n  let hash: Hash | undefined;\n  for (const log of receipt.logs) {\n    try {\n      const priorityQueueLog = decodeEventLog({\n        abi: ZkSyncAbi,\n        data: log.data,\n        topics: log.topics,\n        strict: false,\n      });\n      if (priorityQueueLog && (priorityQueueLog.args as any).txHash !== null)\n        hash = (priorityQueueLog.args as any).txHash;\n    } catch (_e) {\n      // Usually gets here if one of the events is not in the abi which is ok\n    }\n  }\n\n  if (!hash) {\n    throw new BaseError('Error getting L2 hash from L1 transaction');\n  }\n  return hash;\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  encodeFunctionData,\n  type PublicClient,\n  type SendTransactionRequest,\n  type SendTransactionReturnType,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport AGWAccountAbi from '../abis/AGWAccount.js';\nimport { EOA_VALIDATOR_ADDRESS } from '../constants.js';\nimport { type Call } from '../types/call.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport type { SendTransactionBatchParameters } from '../types/sendTransactionBatch.js';\nimport type { SignTransactionBatchParameters } from '../types/signTransactionBatch.js';\nimport { signPrivyTransaction } from './sendPrivyTransaction.js';\nimport { sendTransactionInternal } from './sendTransactionInternal.js';\n\nexport function getBatchTransactionObject<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n>(\n  address: Address,\n  parameters:\n    | SendTransactionBatchParameters<request>\n    | SignTransactionBatchParameters<chain, account, chainOverride>,\n) {\n  const { calls, paymaster, paymasterInput } = parameters;\n  const batchCalls: Call[] = calls.map((tx) => {\n    if (!tx.to) throw new Error('Transaction target (to) is required');\n    return {\n      target: tx.to,\n      allowFailure: false,\n      value: BigInt(tx.value ?? 0),\n      callData: tx.data ?? '0x',\n    };\n  });\n\n  const batchCallData = encodeFunctionData({\n    abi: AGWAccountAbi,\n    functionName: 'batchCall',\n    args: [batchCalls],\n  });\n\n  // Get cumulative value passed in\n  const totalValue = batchCalls.reduce(\n    (sum, call) => sum + BigInt(call.value),\n    BigInt(0),\n  );\n\n  const batchTransaction = {\n    to: address,\n    data: batchCallData,\n    value: totalValue,\n    paymaster: paymaster,\n    paymasterInput: paymasterInput,\n    type: 'eip712',\n  } as any;\n\n  return batchTransaction;\n}\n\n/**\n * Function to send a batch of transactions in a single call using the connected Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { encodeFunctionData, parseUnits } from \"viem\";\n *\n * export default function SendTransactionBatch() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function sendTransactionBatch() {\n *     if (!agwClient) return;\n *\n *     // Batch multiple transactions in a single call\n *     const hash = await agwClient.sendTransactionBatch({\n *       calls: [\n *         // 1. Simple ETH transfer\n *         {\n *           to: \"0x1234567890123456789012345678901234567890\",\n *           value: parseUnits(\"0.1\", 18), // 0.1 ETH\n *         },\n *         // 2. Contract interaction\n *         {\n *           to: \"0xabcdef0123456789abcdef0123456789abcdef01\",\n *           data: encodeFunctionData({\n *             abi: [\n *               {\n *                 name: \"transfer\",\n *                 type: \"function\",\n *                 inputs: [\n *                   { name: \"to\", type: \"address\" },\n *                   { name: \"amount\", type: \"uint256\" }\n *                 ],\n *                 outputs: [{ type: \"bool\" }],\n *                 stateMutability: \"nonpayable\"\n *               }\n *             ],\n *             functionName: \"transfer\",\n *             args: [\"0x9876543210987654321098765432109876543210\", parseUnits(\"10\", 18)]\n *           })\n *         }\n *       ]\n *     });\n *\n *     console.log(\"Transaction hash:\", hash);\n *   }\n * }\n * ```\n *\n * @param parameters - Parameters for sending a batch of transactions\n * @param parameters.calls - An array of transaction requests. Each transaction can include:\n *   - to: The recipient address (required)\n *   - from: The sender address (defaults to the AGW address)\n *   - data: Contract code or method call with encoded args\n *   - gas: Gas provided for execution\n *   - nonce: Unique transaction identifier\n *   - value: Amount in wei to send\n *   - maxFeePerGas: Total fee per gas\n *   - maxPriorityFeePerGas: Priority fee per gas\n *   - gasPerPubdata: Gas per byte of data\n *   - factoryDeps: Bytecodes of contract dependencies\n *   - customSignature: Custom transaction signature\n *   - type: Transaction type\n * @param parameters.paymaster - Address of the paymaster smart contract that will pay the gas fees\n * @param parameters.paymasterInput - Input data to the paymaster\n * @returns The transaction hash of the submitted transaction batch\n */\nexport async function sendTransactionBatch<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SendTransactionBatchParameters<request>,\n  isPrivyCrossApp = false,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<SendTransactionReturnType> {\n  const { calls, ...rest } = parameters;\n  if (calls.length === 0) {\n    throw new Error('No calls provided');\n  }\n  if (isPrivyCrossApp) {\n    const signedTx = await signPrivyTransaction(client, parameters as any);\n    return await publicClient.sendRawTransaction({\n      serializedTransaction: signedTx,\n    });\n  }\n\n  const batchTransaction = getBatchTransactionObject(\n    client.account.address,\n    parameters,\n  );\n\n  return sendTransactionInternal(\n    client,\n    signerClient,\n    publicClient,\n    {\n      ...batchTransaction,\n      ...rest,\n    },\n    EOA_VALIDATOR_ADDRESS,\n    {},\n    customPaymasterHandler,\n  );\n}\n","import {\n  type Account,\n  type Client,\n  type Hex,\n  type SendTransactionRequest,\n  type SignMessageParameters,\n  type SignTypedDataParameters,\n  toHex,\n  type Transport,\n} from 'viem';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type SignEip712TransactionParameters,\n  type SignEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport { replaceBigInts } from '../replaceBigInts.js';\nimport type { SendTransactionBatchParameters } from '../types/sendTransactionBatch.js';\nimport type { SignTransactionBatchParameters } from '../types/signTransactionBatch.js';\nexport async function sendPrivyTransaction<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  const request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters:\n    | SendEip712TransactionParameters<chain, account, chainOverride, request>\n    | SendTransactionBatchParameters<request>,\n): Promise<SignEip712TransactionReturnType> {\n  const result = (await client.request(\n    {\n      method: 'privy_sendSmartWalletTx',\n      params: [replaceBigInts(parameters, toHex)],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    { retryCount: 0 },\n  )) as SignEip712TransactionReturnType;\n  return result;\n}\n\nexport async function sendPrivySignMessage(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters: Omit<SignMessageParameters, 'account'>,\n): Promise<Hex> {\n  const result = (await client.request(\n    {\n      method: 'privy_signSmartWalletMessage',\n      params: [parameters.message],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    { retryCount: 0 },\n  )) as Hex;\n  return result;\n}\n\nexport async function sendPrivySignTypedData(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters: Omit<SignTypedDataParameters, 'account' | 'privateKey'>,\n): Promise<Hex> {\n  const result = (await client.request(\n    {\n      method: 'privy_signSmartWalletTypedData',\n      params: [client.account.address, parameters],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    { retryCount: 0 },\n  )) as Hex;\n  return result;\n}\n\nexport async function signPrivyTransaction<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  parameters:\n    | SignEip712TransactionParameters<chain, account, chainOverride>\n    | SignTransactionBatchParameters<chain, account, chainOverride>,\n): Promise<SignEip712TransactionReturnType> {\n  const { chain: _chain, account: _account, ...request } = parameters;\n\n  const result = (await client.request(\n    {\n      method: 'privy_signSmartWalletTx',\n      params: [replaceBigInts(request, toHex)],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    { retryCount: 0 },\n  )) as SignEip712TransactionReturnType;\n  return result;\n}\n","import {\n  type Account,\n  type Address,\n  BaseError,\n  type Chain,\n  type Client,\n  type Hex,\n  type PublicClient,\n  type SendTransactionRequest,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport { getChainId, sendRawTransaction } from 'viem/actions';\nimport {\n  assertCurrentChain,\n  getAction,\n  getTransactionError,\n  type GetTransactionErrorParameters,\n  parseAccount,\n} from 'viem/utils';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type SendEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport { INSUFFICIENT_BALANCE_SELECTOR } from '../constants.js';\nimport { AccountNotFoundError } from '../errors/account.js';\nimport { InsufficientBalanceError } from '../errors/insufficientBalance.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { prepareTransactionRequest } from './prepareTransaction.js';\nimport { signTransaction } from './signTransaction.js';\n\nexport async function sendTransactionInternal<\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n  validator: Address,\n  validationHookData: Record<string, Hex> = {},\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<SendEip712TransactionReturnType> {\n  const { chain = client.chain } = parameters;\n\n  if (!signerClient.account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    });\n  const account = parseAccount(signerClient.account);\n\n  try {\n    // assertEip712Request(parameters)\n\n    // Prepare the request for signing (assign appropriate fees, etc.)\n    const request = await prepareTransactionRequest(\n      client,\n      signerClient,\n      publicClient,\n      {\n        ...parameters,\n        parameters: ['gas', 'nonce', 'fees'],\n        isSponsored:\n          customPaymasterHandler !== undefined ||\n          (parameters as any).paymaster !== undefined,\n        nonceManager: account.nonceManager,\n      } as any,\n    );\n\n    let chainId: number | undefined;\n    if (chain !== null) {\n      chainId = await getAction(signerClient, getChainId, 'getChainId')({});\n      assertCurrentChain({\n        currentChainId: chainId,\n        chain,\n      });\n    }\n\n    const serializedTransaction = await signTransaction(\n      client,\n      signerClient,\n      publicClient,\n      {\n        ...request,\n        chainId,\n      } as any,\n      validator,\n      validationHookData,\n      customPaymasterHandler,\n    );\n    return await getAction(\n      client,\n      sendRawTransaction,\n      'sendRawTransaction',\n    )({\n      serializedTransaction,\n    });\n  } catch (err) {\n    if (\n      err instanceof Error &&\n      err.message.includes(INSUFFICIENT_BALANCE_SELECTOR)\n    ) {\n      throw new InsufficientBalanceError();\n    }\n    throw getTransactionError(err as BaseError, {\n      ...(parameters as GetTransactionErrorParameters),\n      account,\n      chain: chain as Chain,\n    });\n  }\n}\n","import { BaseError } from 'viem';\n\nexport class InsufficientBalanceError extends BaseError {\n  constructor() {\n    super(['Insufficient balance for transaction.'].join('\\n'), {\n      name: 'InsufficientBalanceError',\n    });\n  }\n}\n","import type { Address } from 'abitype';\nimport {\n  type Account,\n  BaseError,\n  type Chain,\n  type Client,\n  type DeriveAccount,\n  type DeriveChain,\n  encodeFunctionData,\n  type ExactPartial,\n  ExecutionRevertedError,\n  formatGwei,\n  type FormattedTransactionRequest,\n  type GetChainParameter,\n  type GetTransactionRequestKzgParameter,\n  type IsNever,\n  keccak256,\n  type NonceManager,\n  type Prettify,\n  type PublicClient,\n  RpcRequestError,\n  type SendTransactionParameters,\n  toBytes,\n  type TransactionRequest,\n  type TransactionRequestEIP1559,\n  type TransactionRequestEIP2930,\n  type TransactionRequestEIP4844,\n  type TransactionRequestEIP7702,\n  type TransactionRequestLegacy,\n  type Transport,\n  type UnionOmit,\n  type UnionRequiredBy,\n  type WalletClient,\n} from 'viem';\nimport { type ParseAccountErrorType } from 'viem/accounts';\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateGas,\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  getBalance,\n  type GetBlockErrorType,\n  getChainId as getChainId_,\n  getTransactionCount,\n  type GetTransactionCountErrorType,\n} from 'viem/actions';\nimport {\n  assertRequest,\n  type AssertRequestErrorType,\n  getAction,\n  type GetTransactionType,\n  parseAccount,\n} from 'viem/utils';\nimport {\n  type ChainEIP712,\n  estimateFee,\n  type EstimateFeeParameters,\n  type EstimateFeeReturnType,\n} from 'viem/zksync';\n\nimport {\n  CONTRACT_DEPLOYER_ADDRESS,\n  EOA_VALIDATOR_ADDRESS,\n  INSUFFICIENT_BALANCE_SELECTOR,\n  SMART_ACCOUNT_FACTORY_ADDRESS,\n} from '../constants.js';\nimport { InsufficientBalanceError } from '../errors/insufficientBalance.js';\nimport { AccountFactoryAbi } from '../exports/constants.js';\nimport type { Call } from '../types/call.js';\nimport { isSmartAccountDeployed, transformHexValues } from '../utils.js';\nimport { getInitializerCalldata } from '../utils.js';\n\nexport type IsUndefined<T> = [undefined] extends [T] ? true : false;\n\nexport const defaultParameters = [\n  'blobVersionedHashes',\n  'chainId',\n  'fees',\n  'gas',\n  'nonce',\n  'type',\n] as const;\n\nexport type AssertRequestParameters = ExactPartial<\n  SendTransactionParameters<Chain>\n>;\n\nexport class MaxFeePerGasTooLowError extends BaseError {\n  constructor({ maxPriorityFeePerGas }: { maxPriorityFeePerGas: bigint }) {\n    super(\n      `\\`maxFeePerGas\\` cannot be less than the \\`maxPriorityFeePerGas\\` (${formatGwei(\n        maxPriorityFeePerGas,\n      )} gwei).`,\n      { name: 'MaxFeePerGasTooLowError' },\n    );\n  }\n}\n\nexport type GetAccountParameter<\n  account extends Account | undefined = Account | undefined,\n  accountOverride extends Account | Address | undefined = Account | Address,\n  required extends boolean = true,\n> =\n  IsUndefined<account> extends true\n    ? required extends true\n      ? { account: accountOverride | Account | Address }\n      : { account?: accountOverride | Account | Address | undefined }\n    : { account?: accountOverride | Account | Address | undefined };\n\nexport type PrepareTransactionRequestParameterType =\n  | 'blobVersionedHashes'\n  | 'chainId'\n  | 'fees'\n  | 'gas'\n  | 'nonce'\n  | 'sidecars'\n  | 'type';\ntype ParameterTypeToParameters<\n  parameterType extends PrepareTransactionRequestParameterType,\n> = parameterType extends 'fees'\n  ? 'maxFeePerGas' | 'maxPriorityFeePerGas' | 'gasPrice'\n  : parameterType;\n\nexport type PrepareTransactionRequestRequest<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  ///\n  _derivedChain extends ChainEIP712 | undefined = DeriveChain<\n    chain,\n    chainOverride\n  >,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter & {\n    /**\n     * Nonce manager to use for the transaction request.\n     */\n    nonceManager?: NonceManager | undefined;\n    /**\n     * Parameters to prepare for the transaction request.\n     *\n     * @default ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type']\n     */\n    parameters?: readonly PrepareTransactionRequestParameterType[] | undefined;\n\n    /**\n     * Whether the transaction is the first transaction of the account.\n     */\n    isInitialTransaction?: boolean;\n  };\n\nexport type PrepareTransactionRequestParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, accountOverride, false> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & {\n    chainId?: number | undefined;\n  };\n\nexport type PrepareTransactionRequestReturnType<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n  ///\n  _derivedAccount extends Account | Address | undefined = DeriveAccount<\n    account,\n    accountOverride\n  >,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n  _transactionType = request['type'] extends string | undefined\n    ? request['type']\n    : GetTransactionType<request> extends 'legacy'\n      ? unknown\n      : GetTransactionType<request>,\n  _transactionRequest extends TransactionRequest =\n    | (_transactionType extends 'legacy' ? TransactionRequestLegacy : never)\n    | (_transactionType extends 'eip1559' ? TransactionRequestEIP1559 : never)\n    | (_transactionType extends 'eip2930' ? TransactionRequestEIP2930 : never)\n    | (_transactionType extends 'eip4844' ? TransactionRequestEIP4844 : never)\n    | (_transactionType extends 'eip7702' ? TransactionRequestEIP7702 : never),\n> = Prettify<\n  UnionRequiredBy<\n    Extract<\n      UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n        (_derivedChain extends Chain\n          ? { chain: _derivedChain }\n          : { chain?: undefined }) &\n        (_derivedAccount extends Account\n          ? { account: _derivedAccount; from: Address }\n          : { account?: undefined; from?: undefined }),\n      IsNever<_transactionRequest> extends true\n        ? unknown\n        : ExactPartial<_transactionRequest>\n    > & { chainId?: number | undefined },\n    ParameterTypeToParameters<\n      request['parameters'] extends readonly PrepareTransactionRequestParameterType[]\n        ? request['parameters'][number]\n        : (typeof defaultParameters)[number]\n    >\n  > &\n    (unknown extends request['kzg'] ? {} : Pick<request, 'kzg'>)\n>;\n\nexport type PrepareTransactionRequestErrorType =\n  | AssertRequestErrorType\n  | ParseAccountErrorType\n  | GetBlockErrorType\n  | GetTransactionCountErrorType\n  | EstimateGasErrorType\n  | EstimateFeesPerGasErrorType;\n\n/**\n * Prepares a transaction request for signing.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n *\n * @param args - {@link PrepareTransactionRequestParameters}\n * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0xâ€¦'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function prepareTransactionRequest<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  const request extends PrepareTransactionRequestRequest<\n    chain,\n    chainOverride\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  args: PrepareTransactionRequestParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride,\n    request\n  >,\n): Promise<PrepareTransactionRequestReturnType> {\n  // transform values in case any are provided in hex format (from rpc)\n  transformHexValues(args, [\n    'value',\n    'nonce',\n    'maxFeePerGas',\n    'maxPriorityFeePerGas',\n    'gas',\n    'chainId',\n    'gasPerPubdata',\n  ]);\n\n  const isSponsored =\n    'paymaster' in args &&\n    'paymasterInput' in args &&\n    args.paymaster !== undefined &&\n    args.paymasterInput !== undefined;\n\n  const {\n    gas,\n    nonce,\n    chain,\n    nonceManager,\n    parameters: parameterNames = defaultParameters,\n  } = args;\n\n  const isDeployed = await isSmartAccountDeployed(\n    publicClient,\n    client.account.address,\n  );\n\n  if (!isDeployed) {\n    const initialCall = {\n      target: args.to,\n      allowFailure: false,\n      value: args.value ?? 0,\n      callData: args.data ?? '0x',\n    } as Call;\n\n    // Create calldata for initializing the proxy account\n    const initializerCallData = getInitializerCalldata(\n      signerClient.account.address,\n      EOA_VALIDATOR_ADDRESS,\n      initialCall,\n    );\n    const addressBytes = toBytes(signerClient.account.address);\n    const salt = keccak256(addressBytes);\n    const deploymentCalldata = encodeFunctionData({\n      abi: AccountFactoryAbi,\n      functionName: 'deployAccount',\n      args: [salt, initializerCallData],\n    });\n\n    // Override transaction fields\n    args.to = SMART_ACCOUNT_FACTORY_ADDRESS;\n    args.data = deploymentCalldata;\n  }\n\n  const initiatorAccount = parseAccount(\n    isDeployed ? client.account : signerClient.account,\n  );\n  const request = {\n    ...args,\n    from: initiatorAccount.address,\n  };\n\n  // Prepare all async operations that can run in parallel\n  const asyncOperations = [];\n  let userBalance: bigint | undefined;\n\n  // Get balance if the transaction is not sponsored or has a value\n  if (!isSponsored || (request.value !== undefined && request.value > 0n)) {\n    asyncOperations.push(\n      getBalance(publicClient, {\n        address: initiatorAccount.address,\n      }).then((balance: bigint) => {\n        userBalance = balance;\n      }),\n    );\n  }\n\n  let chainId: number | undefined;\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId;\n    if (chain) return chain.id;\n    if (typeof args.chainId !== 'undefined') return args.chainId;\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({});\n    chainId = chainId_;\n    return chainId;\n  }\n\n  // Get nonce if needed\n  if (\n    parameterNames.includes('nonce') &&\n    typeof nonce === 'undefined' &&\n    initiatorAccount\n  ) {\n    if (nonceManager) {\n      asyncOperations.push(\n        (async () => {\n          const chainId = await getChainId();\n          request.nonce = await nonceManager.consume({\n            address: initiatorAccount.address,\n            chainId,\n            client: publicClient,\n          });\n        })(),\n      );\n    } else {\n      asyncOperations.push(\n        getAction(\n          publicClient,\n          getTransactionCount,\n          'getTransactionCount',\n        )({\n          address: initiatorAccount.address,\n          blockTag: 'pending',\n        }).then((nonce) => {\n          request.nonce = nonce;\n        }),\n      );\n    }\n  }\n\n  let gasLimitFromFeeEstimation: bigint | undefined;\n  // Estimate fees if needed\n  if (parameterNames.includes('fees')) {\n    if (\n      typeof request.maxFeePerGas === 'undefined' ||\n      typeof request.maxPriorityFeePerGas === 'undefined'\n    ) {\n      asyncOperations.push(\n        (async () => {\n          let maxFeePerGas: bigint | undefined;\n          let maxPriorityFeePerGas: bigint | undefined;\n          // Skip fee estimation for contract deployments\n          if (request.to === CONTRACT_DEPLOYER_ADDRESS) {\n            maxFeePerGas = 25000000n;\n            maxPriorityFeePerGas = 0n;\n          } else {\n            const estimateFeeRequest: EstimateFeeParameters<\n              chain,\n              account | undefined,\n              ChainEIP712\n            > = {\n              account: initiatorAccount,\n              to: request.to,\n              value: request.value,\n              data: request.data,\n              gas: request.gas,\n              nonce: request.nonce,\n              chainId: request.chainId,\n              authorizationList: [],\n            };\n            let feeEstimation: EstimateFeeReturnType | undefined;\n            try {\n              feeEstimation = await estimateFee(\n                publicClient,\n                estimateFeeRequest,\n              );\n            } catch (error) {\n              if (\n                error instanceof Error &&\n                error.message.includes(INSUFFICIENT_BALANCE_SELECTOR)\n              ) {\n                throw new InsufficientBalanceError();\n              } else if (\n                error instanceof RpcRequestError &&\n                error.details.includes('execution reverted')\n              ) {\n                throw new ExecutionRevertedError({\n                  message: `${error.data}`,\n                });\n              }\n              throw error;\n            }\n            maxFeePerGas = feeEstimation.maxFeePerGas;\n            maxPriorityFeePerGas = feeEstimation.maxPriorityFeePerGas;\n            gasLimitFromFeeEstimation = feeEstimation.gasLimit;\n          }\n\n          if (\n            typeof args.maxPriorityFeePerGas === 'undefined' &&\n            args.maxFeePerGas &&\n            args.maxFeePerGas < maxPriorityFeePerGas\n          )\n            throw new MaxFeePerGasTooLowError({\n              maxPriorityFeePerGas,\n            });\n\n          request.maxPriorityFeePerGas = maxPriorityFeePerGas;\n          request.maxFeePerGas = maxFeePerGas;\n          // set gas to gasFromFeeEstimation if gas is not already set\n          if (typeof gas === 'undefined') {\n            request.gas = gasLimitFromFeeEstimation;\n          }\n        })(),\n      );\n    }\n  }\n\n  // Wait for all async operations to complete\n  await Promise.all(asyncOperations);\n\n  // Check if user has enough balance\n  const gasCost =\n    isSponsored || !request.gas || !request.maxFeePerGas\n      ? 0n\n      : request.gas * request.maxFeePerGas;\n\n  if (\n    userBalance !== undefined &&\n    userBalance < (request.value ?? 0n) + gasCost\n  ) {\n    throw new InsufficientBalanceError();\n  }\n\n  // Estimate gas limit if needed\n  if (\n    parameterNames.includes('gas') &&\n    typeof gas === 'undefined' &&\n    gasLimitFromFeeEstimation === undefined // if gas was set by fee estimation, don't estimate again\n  ) {\n    request.gas = await getAction(\n      client,\n      estimateGas,\n      'estimateGas',\n    )({\n      ...request,\n      account: initiatorAccount\n        ? { address: initiatorAccount.address, type: 'json-rpc' }\n        : undefined,\n    } as EstimateGasParameters);\n  }\n\n  assertRequest(request as AssertRequestParameters);\n\n  delete request.parameters;\n  delete request.isInitialTransaction;\n  delete request.nonceManager;\n\n  return request as any;\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  createClient,\n  createPublicClient,\n  createWalletClient,\n  custom,\n  http,\n  type NonceManager,\n  type Transport,\n} from 'viem';\nimport { toAccount } from 'viem/accounts';\nimport type { ChainEIP712 } from 'viem/chains';\n\nimport type { AbstractClient } from './abstractClient.js';\nimport type { SessionConfig } from './sessions.js';\nimport type { CustomPaymasterHandler } from './types/customPaymaster.js';\nimport {\n  type SessionClientActions,\n  sessionWalletActions,\n} from './walletActions.js';\n\ntype GetNonceManagerParameter<account extends Account | Address = Address> =\n  account extends Account\n    ? { nonceManager?: never }\n    : { nonceManager?: NonceManager };\n\ntype CreateSessionClientParameters<\n  account extends Account | Address = Address,\n> = {\n  account: account;\n  chain: ChainEIP712;\n  signer: Account;\n  session: SessionConfig;\n  transport?: Transport;\n  paymasterHandler?: CustomPaymasterHandler;\n} & GetNonceManagerParameter<account>;\n\nexport type SessionClient = Client<Transport, ChainEIP712, Account> &\n  SessionClientActions;\n\nexport interface ToSessionClientParams {\n  client: AbstractClient;\n  signer: Account;\n  session: SessionConfig;\n  paymasterHandler?: CustomPaymasterHandler;\n}\n\n/**\n * Function to create an AbstractClient using a session key.\n *\n * Creates a new SessionClient instance that can submit transactions and perform actions from\n * the Abstract Global wallet signed by a session key. If a transaction violates any of the\n * session key's policies, it will be rejected.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { parseAbi } from \"viem\";\n * import { abstractTestnet } from \"viem/chains\";\n * import { useAccount } from \"wagmi\";\n *\n * export default function Example() {\n *   const { address } = useAccount();\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function sendTransactionWithSessionKey() {\n *     if (!agwClient || !address) return;\n *\n *     // Use the existing session signer and session that you created with useCreateSession\n *     const sessionClient = agwClient.toSessionClient(sessionSigner, session);\n *\n *     const hash = await sessionClient.writeContract({\n *       abi: parseAbi([\"function mint(address,uint256) external\"]),\n *       account: sessionClient.account,\n *       chain: abstractTestnet,\n *       address: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\",\n *       functionName: \"mint\",\n *       args: [address, BigInt(1)],\n *     });\n *   }\n *\n *   return <button onClick={sendTransactionWithSessionKey}>Send Transaction with Session Key</button>;\n * }\n * ```\n *\n * @param params - Parameters for creating a session client from an existing AbstractClient\n * @param params.client - The AbstractClient to create the session client from\n * @param params.signer - The account that will be used to sign transactions (must match the signer address in the session configuration)\n * @param params.session - The session configuration created by createSession\n * @param params.paymasterHandler - Optional custom paymaster handler\n * @returns A new AbstractClient instance that uses the session key for signing transactions\n */\nexport function toSessionClient({\n  client,\n  signer,\n  session,\n  paymasterHandler,\n}: ToSessionClientParams) {\n  return createSessionClient({\n    account: client.account,\n    chain: client.chain,\n    session,\n    signer,\n    transport: custom(client.transport),\n    paymasterHandler,\n  });\n}\n\n/**\n * Function to create a new SessionClient without an existing AbstractClient.\n *\n * Creates a new SessionClient instance directly, without requiring an existing AbstractClient.\n * If you already have an AbstractClient, use the toSessionClient method instead.\n *\n * @example\n * ```tsx\n * import { createSessionClient } from \"@abstract-foundation/agw-client/sessions\";\n * import { abstractTestnet } from \"viem/chains\";\n * import { http, parseAbi } from \"viem\";\n * import { privateKeyToAccount, generatePrivateKey } from \"viem/accounts\";\n *\n * // The session signer (from createSession)\n * const sessionPrivateKey = generatePrivateKey();\n * const sessionSigner = privateKeyToAccount(sessionPrivateKey);\n *\n * // Create a session client directly\n * const sessionClient = createSessionClient({\n *   account: \"0x1234...\", // The Abstract Global Wallet address\n *   chain: abstractTestnet,\n *   signer: sessionSigner,\n *   session: {\n *     // ... See createSession docs for session configuration options\n *   },\n *   transport: http(), // Optional - defaults to http()\n * });\n *\n * // Use the session client to make transactions\n * const hash = await sessionClient.writeContract({\n *   address: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\",\n *   abi: parseAbi([\"function mint(address,uint256) external\"]),\n *   functionName: \"mint\",\n *   args: [address, BigInt(1)],\n * });\n * ```\n *\n * @param params - Parameters for creating a session client directly\n * @param params.account - The Abstract Global Wallet address or Account object that the session key will act on behalf of (required)\n * @param params.chain - The chain configuration object that supports EIP-712 (required)\n * @param params.signer - The session key account that will be used to sign transactions (required)\n * @param params.session - The session configuration created by createSession (required)\n * @param params.transport - The transport configuration for connecting to the network (defaults to HTTP if not provided)\n * @param params.paymasterHandler - Optional custom paymaster handler\n * @param params.nonceManager - Optional nonce manager\n * @returns A new SessionClient instance that uses the session key for signing transactions\n */\nexport function createSessionClient<\n  account extends Account | Address = Address,\n>({\n  account,\n  signer,\n  chain,\n  transport,\n  session,\n  paymasterHandler,\n  nonceManager,\n}: CreateSessionClientParameters<account>) {\n  if (!transport) {\n    transport = http();\n  }\n\n  const publicClient = createPublicClient({\n    transport,\n    chain,\n  });\n\n  const parsedAccount: Account =\n    typeof account === 'string' ? toAccount(account) : account;\n  if (nonceManager) {\n    parsedAccount.nonceManager = nonceManager;\n  }\n\n  const baseClient = createClient({\n    account: parsedAccount,\n    chain: chain,\n    transport,\n  });\n\n  const signerWalletClient = createWalletClient({\n    account: signer,\n    chain: chain,\n    transport,\n  });\n\n  const sessionClient = baseClient.extend(\n    sessionWalletActions(\n      signerWalletClient,\n      publicClient,\n      session,\n      paymasterHandler,\n    ),\n  );\n\n  return sessionClient as SessionClient;\n}\n","import {\n  type Abi,\n  type Account,\n  type Address,\n  type Chain,\n  type Client,\n  type GetChainIdReturnType,\n  type Hash,\n  type PrepareTransactionRequestReturnType,\n  type PublicClient,\n  type SendTransactionRequest,\n  type SendTransactionReturnType,\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  type Transport,\n  type WalletActions,\n  walletActions,\n  type WalletClient,\n  type WriteContractParameters,\n} from 'viem';\nimport { parseAccount, type SignTransactionReturnType } from 'viem/accounts';\nimport { getChainId } from 'viem/actions';\nimport {\n  type ChainEIP712,\n  type Eip712WalletActions,\n  type SendEip712TransactionParameters,\n  type SignEip712TransactionParameters,\n  type SignEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport { type AbstractClient } from './abstractClient.js';\nimport {\n  createSession,\n  type CreateSessionParameters,\n  type CreateSessionReturnType,\n} from './actions/createSession.js';\nimport { deployContract } from './actions/deployContract.js';\nimport {\n  getLinkedAccounts,\n  type GetLinkedAccountsParameters,\n  type GetLinkedAccountsReturnType,\n} from './actions/getLinkedAccounts.js';\nimport {\n  getLinkedAgw,\n  type GetLinkedAgwParameters,\n  type GetLinkedAgwReturnType,\n  isLinkedAccount,\n  type IsLinkedAccountParameters,\n} from './actions/getLinkedAgw.js';\nimport { getSessionStatus } from './actions/getSessionStatus.js';\nimport {\n  linkToAgw,\n  type LinkToAgwParameters,\n  type LinkToAgwReturnType,\n} from './actions/linkToAgw.js';\nimport {\n  prepareTransactionRequest,\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestRequest,\n} from './actions/prepareTransaction.js';\nimport {\n  revokeSessions,\n  type RevokeSessionsParameters,\n  type RevokeSessionsReturnType,\n} from './actions/revokeSessions.js';\nimport { sendTransaction } from './actions/sendTransaction.js';\nimport { sendTransactionBatch } from './actions/sendTransactionBatch.js';\nimport { sendTransactionForSession } from './actions/sendTransactionForSession.js';\nimport { signMessage } from './actions/signMessage.js';\nimport { signTransaction } from './actions/signTransaction.js';\nimport { signTransactionBatch } from './actions/signTransactionBatch.js';\nimport { signTransactionForSession } from './actions/signTransactionForSession.js';\nimport {\n  signTypedData,\n  signTypedDataForSession,\n} from './actions/signTypedData.js';\nimport { writeContract } from './actions/writeContract.js';\nimport { writeContractForSession } from './actions/writeContractForSession.js';\nimport { EOA_VALIDATOR_ADDRESS } from './constants.js';\nimport { type SessionClient, toSessionClient } from './sessionClient.js';\nimport type { SessionConfig, SessionStatus } from './sessions.js';\nimport type { CustomPaymasterHandler } from './types/customPaymaster.js';\nimport type { SendTransactionBatchParameters } from './types/sendTransactionBatch.js';\nimport type { SignTransactionBatchParameters } from './types/signTransactionBatch.js';\n\nexport type AbstractWalletActions<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n> = Eip712WalletActions<chain, account> & {\n  getChainId: () => Promise<GetChainIdReturnType>;\n  getLinkedAccounts: (\n    args: GetLinkedAccountsParameters,\n  ) => Promise<GetLinkedAccountsReturnType>;\n  isLinkedAccount: (args: IsLinkedAccountParameters) => Promise<boolean>;\n  createSession: (\n    args: CreateSessionParameters,\n  ) => Promise<CreateSessionReturnType>;\n  revokeSessions: (\n    args: RevokeSessionsParameters,\n  ) => Promise<RevokeSessionsReturnType>;\n  signMessage: (\n    args: Omit<SignMessageParameters, 'account'>,\n  ) => Promise<SignMessageReturnType>;\n  signTypedData: (\n    args: Omit<SignTypedDataParameters, 'account' | 'privateKey'>,\n  ) => Promise<SignTypedDataReturnType>;\n  sendTransactionBatch: <\n    const request extends SendTransactionRequest<ChainEIP712>,\n  >(\n    args: SendTransactionBatchParameters<request>,\n  ) => Promise<SendTransactionReturnType>;\n  signTransactionBatch: (\n    args: SignTransactionBatchParameters<chain, account>,\n  ) => Promise<SignEip712TransactionReturnType>;\n  prepareAbstractTransactionRequest: <\n    chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n    account extends Account | undefined = Account | undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n    chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n    const request extends PrepareTransactionRequestRequest<\n      chain,\n      chainOverride\n    > = PrepareTransactionRequestRequest<chain, chainOverride>,\n  >(\n    args: PrepareTransactionRequestParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >,\n  ) => Promise<PrepareTransactionRequestReturnType>;\n  toSessionClient: (signer: Account, session: SessionConfig) => SessionClient;\n  getSessionStatus: (\n    sessionHashOrConfig: Hash | SessionConfig,\n  ) => Promise<SessionStatus>;\n};\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport type SessionClientActions<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = undefined,\n> = {\n  sendTransaction: <\n    const request extends SendTransactionRequest<chain, chainOverride>,\n    chainOverride extends ChainEIP712 | undefined = undefined,\n  >(\n    args: SendEip712TransactionParameters<\n      chain,\n      account,\n      chainOverride,\n      request\n    >,\n  ) => Promise<SendTransactionReturnType>;\n  signTransaction: (\n    args: SignEip712TransactionParameters<chain, account, chainOverride>,\n  ) => Promise<SignTransactionReturnType>;\n  writeContract: WalletActions<chain, account>['writeContract'];\n  signTypedData: WalletActions<chain, account>['signTypedData'];\n  getSessionStatus: () => Promise<SessionStatus>;\n};\n\nexport type LinkableWalletActions<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = WalletActions<chain, account> & {\n  linkToAgw: (args: LinkToAgwParameters) => Promise<LinkToAgwReturnType>;\n  getLinkedAgw: () => Promise<GetLinkedAgwReturnType>;\n};\n\nexport interface LinkablePublicActions {\n  getLinkedAgw: (\n    args: GetLinkedAgwParameters,\n  ) => Promise<GetLinkedAgwReturnType>;\n  getLinkedAccounts: (\n    args: GetLinkedAccountsParameters,\n  ) => Promise<GetLinkedAccountsReturnType>;\n}\n\nexport function sessionWalletActions(\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  session: SessionConfig,\n  paymasterHandler?: CustomPaymasterHandler,\n) {\n  return (\n    client: Client<Transport, ChainEIP712, Account>,\n  ): SessionClientActions<Chain, Account> => ({\n    sendTransaction: (args) =>\n      sendTransactionForSession(\n        client,\n        signerClient,\n        publicClient,\n        args,\n        session,\n        paymasterHandler,\n      ),\n    writeContract: (args) =>\n      writeContractForSession(\n        client,\n        signerClient,\n        publicClient,\n        args,\n        session,\n        paymasterHandler,\n      ),\n    signTransaction: (args) =>\n      signTransactionForSession(\n        client,\n        signerClient,\n        publicClient,\n        args,\n        session,\n        paymasterHandler,\n      ),\n    signTypedData: (args) =>\n      signTypedDataForSession(\n        client,\n        signerClient,\n        publicClient,\n        args as any,\n        session,\n        paymasterHandler,\n      ),\n    getSessionStatus: () =>\n      getSessionStatus(\n        publicClient,\n        parseAccount(client.account).address,\n        session,\n      ),\n  });\n}\n\nexport function globalWalletActions<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  isPrivyCrossApp = false,\n  customPaymasterHandler?: CustomPaymasterHandler,\n) {\n  return (\n    client: Client<Transport, ChainEIP712, Account>,\n  ): AbstractWalletActions<Chain, Account> => ({\n    getChainId: () => getChainId(client),\n    getLinkedAccounts: () =>\n      getLinkedAccounts(client, {\n        agwAddress: parseAccount(client.account).address,\n      }),\n    isLinkedAccount: (args) => isLinkedAccount(client, args),\n    createSession: (args) => createSession(client, publicClient, args),\n    revokeSessions: (args) => revokeSessions(client, args),\n    prepareAbstractTransactionRequest: (args) =>\n      prepareTransactionRequest(\n        client,\n        signerClient,\n        publicClient,\n        args as any,\n      ),\n    sendTransaction: (args) =>\n      sendTransaction(\n        client,\n        signerClient,\n        publicClient,\n        args as any,\n        isPrivyCrossApp,\n        customPaymasterHandler,\n      ),\n    sendTransactionBatch: (args) =>\n      sendTransactionBatch(\n        client,\n        signerClient,\n        publicClient,\n        args,\n        isPrivyCrossApp,\n        customPaymasterHandler,\n      ),\n    signMessage: (args: Omit<SignMessageParameters, 'account'>) =>\n      signMessage(client, signerClient, args, isPrivyCrossApp),\n    signTransaction: (args) =>\n      signTransaction(\n        client,\n        signerClient,\n        publicClient,\n        args as SignEip712TransactionParameters<chain, account>,\n        EOA_VALIDATOR_ADDRESS,\n        {},\n        customPaymasterHandler,\n        isPrivyCrossApp,\n      ),\n    signTransactionBatch: (args) =>\n      signTransactionBatch(\n        client,\n        signerClient,\n        publicClient,\n        args as SignTransactionBatchParameters<chain, account>,\n        EOA_VALIDATOR_ADDRESS,\n        {},\n        customPaymasterHandler,\n        isPrivyCrossApp,\n      ),\n    signTypedData: (\n      args: Omit<SignTypedDataParameters, 'account' | 'privateKey'>,\n    ) =>\n      signTypedData(client, signerClient, publicClient, args, isPrivyCrossApp),\n    deployContract: (args) =>\n      deployContract(client, signerClient, publicClient, args, isPrivyCrossApp),\n    writeContract: (args) =>\n      writeContract(\n        Object.assign(client, {\n          sendTransaction: (\n            args: SendEip712TransactionParameters<chain, account>,\n          ) =>\n            sendTransaction(\n              client,\n              signerClient,\n              publicClient,\n              args,\n              isPrivyCrossApp,\n              customPaymasterHandler,\n            ),\n        }),\n        signerClient,\n        publicClient,\n        args as WriteContractParameters<\n          Abi,\n          string,\n          readonly unknown[],\n          ChainEIP712,\n          Account\n        >,\n        isPrivyCrossApp,\n      ),\n    toSessionClient: (signer, session) =>\n      toSessionClient({\n        client: client as AbstractClient,\n        signer,\n        session: session,\n        paymasterHandler: customPaymasterHandler,\n      }),\n    getSessionStatus: (sessionHashOrConfig: Hash | SessionConfig) =>\n      getSessionStatus(\n        publicClient,\n        parseAccount(client.account).address,\n        sessionHashOrConfig,\n      ),\n  });\n}\n\nexport function linkableWalletActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>() {\n  return (\n    client: WalletClient<transport, chain, account>,\n  ): LinkableWalletActions<chain, account> => ({\n    ...walletActions(client),\n    linkToAgw: (args) => linkToAgw(client, args),\n    getLinkedAgw: () => getLinkedAgw(client, {}),\n  });\n}\n\nexport function linkablePublicActions<\n  transport extends Transport = Transport,\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n>() {\n  return (\n    client: Client<transport, chain, account>,\n  ): LinkablePublicActions => ({\n    getLinkedAgw: (args) => getLinkedAgw(client, args),\n    getLinkedAccounts: (args) => getLinkedAccounts(client, args),\n  });\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  createClient,\n  createPublicClient,\n  createWalletClient,\n  http,\n  type Transport,\n} from 'viem';\nimport { toAccount } from 'viem/accounts';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport type { CustomPaymasterHandler } from './types/customPaymaster.js';\nimport { getSmartAccountAddressFromInitialSigner } from './utils.js';\nimport {\n  type AbstractWalletActions,\n  globalWalletActions,\n} from './walletActions.js';\n\n/**\n * Parameters for creating an AbstractClient instance.\n * @interface CreateAbstractClientParameters\n */\ninterface CreateAbstractClientParameters {\n  /**\n   * The account used for signing AGW transactions.\n   * @type {Account}\n   */\n  signer: Account;\n\n  /**\n   * The chain configuration supporting EIP-712.\n   * @type {ChainEIP712}\n   */\n  chain: ChainEIP712;\n\n  /**\n   * Optional transport layer for network communication.\n   * If not provided, a default HTTP transport will be used.\n   * @type {Transport}\n   * @optional\n   */\n  transport?: Transport;\n\n  /**\n   * The address of the smart account.\n   * @type {Address}\n   * @optional\n   */\n  address?: Address;\n\n  /**\n   * Whether the client is a Privy cross-app client.\n   * @type {boolean}\n   * @optional\n   */\n  isPrivyCrossApp?: boolean;\n\n  /**\n   * The transport layer for the underlying public client.\n   * @type {Transport}\n   * @optional\n   */\n  publicTransport?: Transport;\n\n  /**\n   * The custom paymaster handler.\n   * @type {CustomPaymasterHandler}\n   * @optional\n   */\n  customPaymasterHandler?: CustomPaymasterHandler;\n}\n\ntype AbstractClientActions = AbstractWalletActions<ChainEIP712, Account>;\n\nexport type AbstractClient = Client<Transport, ChainEIP712, Account> &\n  AbstractClientActions;\n\nexport async function createAbstractClient({\n  signer,\n  chain,\n  transport,\n  address,\n  isPrivyCrossApp = false,\n  publicTransport = http(),\n  customPaymasterHandler,\n}: CreateAbstractClientParameters): Promise<AbstractClient> {\n  if (!transport) {\n    throw new Error('Transport is required');\n  }\n\n  const publicClient = createPublicClient({\n    chain: chain,\n    transport: publicTransport,\n  });\n\n  const smartAccountAddress =\n    address ??\n    (await getSmartAccountAddressFromInitialSigner(\n      signer.address,\n      publicClient,\n    ));\n\n  const baseClient = createClient({\n    account: toAccount(smartAccountAddress),\n    chain: chain,\n    transport,\n  });\n\n  // Create a signer wallet client to handle actual signing\n  const signerWalletClient = createWalletClient({\n    account: signer,\n    chain: chain,\n    transport,\n  });\n\n  const abstractClient = baseClient.extend(\n    globalWalletActions(\n      signerWalletClient,\n      publicClient,\n      isPrivyCrossApp,\n      customPaymasterHandler,\n    ),\n  );\n  return abstractClient as AbstractClient;\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  concatHex,\n  type Hash,\n  type Hex,\n  type PublicClient,\n  type Transport,\n} from 'viem';\nimport { readContract, writeContract } from 'viem/actions';\nimport type { ChainEIP712 } from 'viem/chains';\nimport { getAction } from 'viem/utils';\n\nimport AGWAccountAbi from '../abis/AGWAccount.js';\nimport { SessionKeyValidatorAbi } from '../abis/SessionKeyValidator.js';\nimport { SESSION_KEY_VALIDATOR_ADDRESS } from '../constants.js';\nimport { encodeSession, type SessionConfig } from '../sessions.js';\nimport { isSmartAccountDeployed } from '../utils.js';\n\nexport interface CreateSessionParameters {\n  session: SessionConfig;\n  paymaster?: Address;\n  paymasterInput?: Hex;\n}\n\nexport interface CreateSessionReturnType {\n  transactionHash: Hash | undefined;\n  session: SessionConfig;\n}\n\n/**\n * Creates a session key for an Abstract Global Wallet.\n *\n * Session keys enable temporary, permissioned access to a wallet, allowing specific actions\n * to be performed without requiring the wallet owner's signature for each transaction.\n *\n * @param args - Parameters for creating the session\n * @param args.session - Session key configuration object\n * @param args.paymaster - Optional address of a paymaster to sponsor the transaction\n * @param args.paymasterInput - Optional data for the paymaster\n * @returns Object containing the transaction hash of the session key creation and the session config\n *\n * @example\n * ```ts\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { LimitType } from \"@abstract-foundation/agw-client/sessions\";\n * import { toFunctionSelector, parseEther } from \"viem\";\n * import { privateKeyToAccount, generatePrivateKey } from \"viem/accounts\";\n *\n * // Generate a new session key pair\n * const sessionPrivateKey = generatePrivateKey();\n * const sessionSigner = privateKeyToAccount(sessionPrivateKey);\n *\n * export default function CreateSession() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function createSession() {\n *     if (!agwClient) return;\n *\n *     const { session } = await agwClient.createSession({\n *       session: {\n *         signer: sessionSigner.address,\n *         expiresAt: BigInt(Math.floor(Date.now() / 1000) + 60 * 60 * 24),\n *         feeLimit: {\n *           limitType: LimitType.Lifetime,\n *           limit: parseEther(\"1\"),\n *           period: BigInt(0),\n *         },\n *         callPolicies: [\n *           {\n *             target: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\",\n *             selector: toFunctionSelector(\"mint(address,uint256)\"),\n *             valueLimit: {\n *               limitType: LimitType.Unlimited,\n *               limit: BigInt(0),\n *               period: BigInt(0),\n *             },\n *             maxValuePerUse: BigInt(0),\n *             constraints: [],\n *           }\n *         ],\n *         transferPolicies: [],\n *       },\n *     });\n *   }\n *\n *   return <button onClick={createSession}>Create Session</button>;\n * }\n * ```\n *\n * @see {@link SessionConfig} - The session configuration type\n * @see {@link encodeSession} - Function to encode a session configuration\n */\nexport async function createSession(\n  client: Client<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  args: CreateSessionParameters,\n): Promise<CreateSessionReturnType> {\n  const { session, ...rest } = args;\n\n  const isDeployed = await isSmartAccountDeployed(\n    publicClient,\n    client.account.address,\n  );\n\n  const hasModule = isDeployed ? await hasSessionModule(client) : false;\n\n  let transactionHash: Hash | undefined = undefined;\n\n  if (!hasModule) {\n    const encodedSession = encodeSession(session);\n    transactionHash = await getAction(\n      client,\n      writeContract,\n      'writeContract',\n    )({\n      address: client.account.address,\n      abi: AGWAccountAbi,\n      functionName: 'addModule',\n      args: [concatHex([SESSION_KEY_VALIDATOR_ADDRESS, encodedSession])],\n      ...rest,\n    } as any);\n  } else {\n    transactionHash = await getAction(\n      client,\n      writeContract,\n      'writeContract',\n    )({\n      address: SESSION_KEY_VALIDATOR_ADDRESS,\n      abi: SessionKeyValidatorAbi,\n      functionName: 'createSession',\n      args: [session as any],\n      ...rest,\n    } as any);\n  }\n\n  return { transactionHash, session };\n}\n\nasync function hasSessionModule(\n  client: Client<Transport, ChainEIP712, Account>,\n) {\n  const validationHooks = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: client.account.address,\n    abi: AGWAccountAbi,\n    functionName: 'listHooks',\n    args: [true],\n  });\n\n  const hasSessionModule = validationHooks.some(\n    (hook) => hook === SESSION_KEY_VALIDATOR_ADDRESS,\n  );\n\n  return hasSessionModule;\n}\n","import {\n  type Abi,\n  type Account,\n  type Client,\n  type ContractConstructorArgs,\n  type PublicClient,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport {\n  type ChainEIP712,\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  encodeDeployData,\n} from 'viem/zksync';\n\nimport { CONTRACT_DEPLOYER_ADDRESS } from '../constants.js';\nimport { sendTransaction } from './sendTransaction.js';\n\n/**\n * Function to deploy a smart contract from the connected Abstract Global Wallet.\n *\n * This extends the deployContract function from Viem to include options for contract deployment on Abstract.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { erc20Abi } from \"viem\"; // example abi\n * import { abstractTestnet } from \"viem/chains\";\n *\n * export default function DeployContract() {\n *     const { data: agwClient } = useAbstractClient();\n *\n *     async function deployContract() {\n *         if (!agwClient) return;\n *\n *         const hash = await agwClient.deployContract({\n *             abi: erc20Abi, // Your smart contract ABI\n *             account: agwClient.account,\n *             bytecode: \"0x...\", // Your smart contract bytecode\n *             chain: abstractTestnet,\n *             args: [], // Constructor arguments\n *         });\n *     }\n * }\n * ```\n *\n * @param parameters - Contract deployment parameters\n * @param parameters.abi - The ABI of the contract to deploy (required)\n * @param parameters.bytecode - The bytecode of the contract to deploy (required)\n * @param parameters.account - The account to deploy the contract from (required)\n * @param parameters.chain - The chain to deploy the contract on, e.g. abstractTestnet / abstract (required)\n * @param parameters.args - Constructor arguments to call upon deployment\n * @param parameters.deploymentType - Specifies the type of contract deployment ('create', 'create2', 'createAccount', 'create2Account'). Defaults to 'create'\n * @param parameters.factoryDeps - An array of bytecodes of contracts that are dependencies for the contract being deployed\n * @param parameters.salt - Specifies a unique identifier for the contract deployment\n * @param parameters.gasPerPubdata - The amount of gas to pay per byte of data on Ethereum\n * @param parameters.paymaster - Address of the paymaster smart contract that will pay the gas fees (requires paymasterInput)\n * @param parameters.paymasterInput - Input data to the paymaster (requires paymaster)\n * @returns The hash of the transaction that deployed the contract\n */\nexport function deployContract<\n  const abi extends Abi | readonly unknown[],\n  chain extends ChainEIP712 | undefined = ChainEIP712,\n  account extends Account | undefined = Account,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712,\n  allArgs = ContractConstructorArgs<abi>,\n>(\n  walletClient: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: DeployContractParameters<\n    abi,\n    chain,\n    account,\n    chainOverride,\n    allArgs\n  >,\n  isPrivyCrossApp = false,\n): Promise<DeployContractReturnType> {\n  const { abi, args, bytecode, deploymentType, salt, ...request } =\n    parameters as DeployContractParameters;\n\n  const data = encodeDeployData({\n    abi,\n    args,\n    bytecode,\n    deploymentType,\n    salt,\n  });\n\n  // Add the bytecode to the factoryDeps if it's not already there\n  request.factoryDeps = request.factoryDeps || [];\n  if (!request.factoryDeps.includes(bytecode))\n    request.factoryDeps.push(bytecode);\n\n  return sendTransaction(\n    walletClient,\n    signerClient,\n    publicClient,\n    {\n      ...request,\n      data,\n      to: CONTRACT_DEPLOYER_ADDRESS,\n    },\n    isPrivyCrossApp,\n  );\n}\n","import {\n  type Account,\n  BaseError,\n  type Client,\n  type PublicClient,\n  type SendTransactionRequest,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport {\n  getTransactionError,\n  type GetTransactionErrorParameters,\n  parseAccount,\n} from 'viem/utils';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type SendEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport {\n  EOA_VALIDATOR_ADDRESS,\n  INSUFFICIENT_BALANCE_SELECTOR,\n} from '../constants.js';\nimport { InsufficientBalanceError } from '../errors/insufficientBalance.js';\nimport type {\n  CustomPaymasterHandler,\n  PaymasterArgs,\n} from '../types/customPaymaster.js';\nimport { signPrivyTransaction } from './sendPrivyTransaction.js';\nimport { sendTransactionInternal } from './sendTransactionInternal.js';\n\n/**\n * Function to send a transaction using the connected Abstract Global Wallet.\n *\n * Transactions are signed by the approved signer account (EOA) of the Abstract Global Wallet\n * and sent from the AGW smart contract itself.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n *\n * export default function SendTransaction() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function sendTransaction() {\n *     if (!agwClient) return;\n *\n *     const hash = await agwClient.sendTransaction({\n *       to: \"0x273B3527BF5b607dE86F504fED49e1582dD2a1C6\",\n *       data: \"0x69\",\n *     });\n *   }\n * }\n * ```\n *\n * @param parameters - Transaction parameters\n * @param parameters.to - The recipient address of the transaction\n * @param parameters.from - The sender address of the transaction (defaults to the Abstract Global Wallet address)\n * @param parameters.data - Contract code or a hashed method call with encoded args\n * @param parameters.gas - Gas provided for transaction execution\n * @param parameters.nonce - Unique number identifying this transaction\n * @param parameters.value - Value in wei sent with this transaction\n * @param parameters.maxFeePerGas - Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas)\n * @param parameters.maxPriorityFeePerGas - Max priority fee per gas (in wei)\n * @param parameters.gasPerPubdata - The amount of gas to pay per byte of data on Ethereum\n * @param parameters.factoryDeps - An array of bytecodes of contracts that are dependencies for the transaction\n * @param parameters.paymaster - Address of the paymaster smart contract that will pay the gas fees (requires paymasterInput)\n * @param parameters.paymasterInput - Input data to the paymaster (requires paymaster)\n * @param parameters.customSignature - Custom signature for the transaction\n * @param parameters.type - Transaction type. For EIP-712 transactions, this should be 'eip712'\n * @returns The transaction hash of the submitted transaction\n */\nexport async function sendTransaction<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  const request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n  isPrivyCrossApp = false,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<SendEip712TransactionReturnType> {\n  if (isPrivyCrossApp) {\n    try {\n      let paymasterData: Partial<PaymasterArgs> = {};\n      // SendEip712TransactionParameters doesn't actually have paymaster or paymasterInput fields\n      // defined, so we just have to cast to any here to access them\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const requestAsAny = parameters as any;\n      if (\n        customPaymasterHandler &&\n        !requestAsAny.paymaster &&\n        !requestAsAny.paymasterInput\n      ) {\n        paymasterData = await customPaymasterHandler({\n          ...(parameters as any),\n          from: client.account.address,\n          chainId: parameters.chain?.id ?? client.chain.id,\n        });\n      }\n\n      const updatedParameters = {\n        ...parameters,\n        ...(paymasterData as any),\n      };\n      const signedTx = await signPrivyTransaction(client, updatedParameters);\n      return await publicClient.sendRawTransaction({\n        serializedTransaction: signedTx,\n      });\n    } catch (err) {\n      if (\n        err instanceof Error &&\n        err.message.includes(INSUFFICIENT_BALANCE_SELECTOR)\n      ) {\n        throw new InsufficientBalanceError();\n      }\n      throw getTransactionError(err as BaseError, {\n        ...(parameters as GetTransactionErrorParameters),\n        account: parameters.account ? parseAccount(parameters.account) : null,\n        chain: parameters.chain ?? undefined,\n      });\n    }\n  }\n\n  return sendTransactionInternal(\n    client,\n    signerClient,\n    publicClient,\n    parameters,\n    EOA_VALIDATOR_ADDRESS,\n    {},\n    customPaymasterHandler,\n  );\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  type Hash,\n  type Hex,\n  type Transport,\n} from 'viem';\nimport { writeContract } from 'viem/actions';\nimport type { ChainEIP712 } from 'viem/chains';\nimport { getAction } from 'viem/utils';\n\nimport { SessionKeyValidatorAbi } from '../abis/SessionKeyValidator.js';\nimport { SESSION_KEY_VALIDATOR_ADDRESS } from '../constants.js';\nimport { getSessionHash, type SessionConfig } from '../sessions.js';\n\nexport interface RevokeSessionsParameters {\n  session: SessionConfig | Hash | (SessionConfig | Hash)[];\n  paymaster?: Address;\n  paymasterInput?: Hex;\n}\nexport interface RevokeSessionsReturnType {\n  transactionHash: Hash | undefined;\n}\n\n/**\n * Function to revoke session keys from the connected Abstract Global Wallet.\n *\n * This allows you to invalidate existing session keys, preventing them from being used for future transactions.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n *\n * export default function RevokeSessions() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function revokeSessions() {\n *     if (!agwClient) return;\n *\n *     // Revoke a single session by passing the session configuration\n *     const { transactionHash } = await agwClient.revokeSessions({\n *       session: existingSession,\n *     });\n *\n *     // Or - revoke multiple sessions at once\n *     const { transactionHash } = await agwClient.revokeSessions({\n *       session: [existingSession1, existingSession2],\n *     });\n *\n *     // Or - revoke sessions using their creation transaction hashes\n *     const { transactionHash } = await agwClient.revokeSessions({\n *       session: \"0x1234...\",\n *     });\n *\n *     // Or - revoke multiple sessions using their creation transaction hashes\n *     const { transactionHash } = await agwClient.revokeSessions({\n *       session: [\"0x1234...\", \"0x5678...\"],\n *     });\n *\n *     // Or - revoke multiple sessions using both session configuration and creation transaction hashes\n *     const { transactionHash } = await agwClient.revokeSessions({\n *       session: [existingSession, \"0x1234...\"],\n *     });\n *   }\n * }\n * ```\n *\n * @param parameters - Parameters for revoking sessions\n * @param parameters.session - The session(s) to revoke (required). Can be provided in three formats:\n *                           - A single SessionConfig object\n *                           - A single session key creation transaction hash from createSession\n *                           - An array of SessionConfig objects and/or session key creation transaction hashes\n * @param parameters.paymaster - Optional paymaster address to sponsor the transaction\n * @param parameters.paymasterInput - Optional paymaster input data\n * @returns Object containing the transaction hash of the revocation transaction\n */\nexport async function revokeSessions(\n  client: Client<Transport, ChainEIP712, Account>,\n  args: RevokeSessionsParameters,\n): Promise<RevokeSessionsReturnType> {\n  const { session, ...rest } = args;\n\n  const sessionHashes =\n    typeof session === 'string'\n      ? [session as Hash]\n      : Array.isArray(session)\n        ? session.map(sessionHash)\n        : [getSessionHash(session)];\n\n  const transactionHash = await getAction(\n    client,\n    writeContract,\n    'writeContract',\n  )({\n    address: SESSION_KEY_VALIDATOR_ADDRESS,\n    abi: SessionKeyValidatorAbi,\n    functionName: 'revokeKeys',\n    args: [sessionHashes],\n    ...rest,\n  } as any);\n\n  return { transactionHash };\n}\n\nfunction sessionHash(session: SessionConfig | Hash): Hash {\n  if (typeof session === 'string') {\n    return session;\n  }\n  return getSessionHash(session);\n}\n","import {\n  type Account,\n  BaseError,\n  type Client,\n  type Hex,\n  type PublicClient,\n  type SendTransactionRequest,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type SendEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport { SESSION_KEY_VALIDATOR_ADDRESS } from '../constants.js';\nimport {\n  encodeSessionWithPeriodIds,\n  getPeriodIdsForTransaction,\n  type SessionConfig,\n} from '../sessions.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { sendTransactionInternal } from './sendTransactionInternal.js';\n\nexport interface SendTransactionForSessionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> {\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >;\n  session: SessionConfig;\n}\n\nexport async function sendTransactionForSession<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  const request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n  session: SessionConfig,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<SendEip712TransactionReturnType> {\n  const selector: Hex | undefined = parameters.data\n    ? `0x${parameters.data.slice(2, 10)}`\n    : undefined;\n\n  if (!parameters.to) {\n    throw new BaseError('Transaction to field is not specified');\n  }\n  return sendTransactionInternal(\n    client,\n    signerClient,\n    publicClient,\n    parameters,\n    SESSION_KEY_VALIDATOR_ADDRESS,\n    {\n      [SESSION_KEY_VALIDATOR_ADDRESS]: encodeSessionWithPeriodIds(\n        session,\n        getPeriodIdsForTransaction({\n          sessionConfig: session,\n          target: parameters.to,\n          selector,\n          timestamp: BigInt(Math.floor(Date.now() / 1000)),\n        }),\n      ),\n    },\n    customPaymasterHandler,\n  );\n}\n","import {\n  type Account,\n  bytesToString,\n  type Client,\n  fromHex,\n  hashMessage,\n  type Hex,\n  type SignMessageParameters,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport type { ChainEIP712 } from 'viem/chains';\n\nimport { getAgwTypedSignature } from '../getAgwTypedSignature.js';\nimport { sendPrivySignMessage } from './sendPrivyTransaction.js';\n\n/**\n * Function to sign messages using the connected Abstract Global Wallet.\n *\n * This method follows the EIP-1271 standard for contract signature verification.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n *\n * export default function SignMessage() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function signMessage() {\n *     if (!agwClient) return;\n *\n *     const signature = await agwClient.signMessage({\n *       message: \"Hello, Abstract!\",\n *     });\n *\n *     console.log(\"Signature:\", signature);\n *   }\n * }\n * ```\n *\n * @param parameters - Parameters for signing a message\n * @param parameters.message - The message to sign. Can be a string or a hex value (required)\n * @returns A Promise containing the signature of the message\n */\nexport async function signMessage(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  parameters: Omit<SignMessageParameters, 'account'>,\n  isPrivyCrossApp = false,\n): Promise<Hex> {\n  if (isPrivyCrossApp) {\n    // We handle {message: {raw}} here because the message is expected to be a string\n    if (typeof parameters.message === 'object') {\n      if (parameters.message.raw instanceof Uint8Array) {\n        parameters.message = bytesToString(parameters.message.raw);\n      } else {\n        parameters.message = fromHex(parameters.message.raw, 'string');\n      }\n    }\n    return await sendPrivySignMessage(client, parameters);\n  }\n\n  return await getAgwTypedSignature({\n    client,\n    signer: signerClient,\n    messageHash: hashMessage(parameters.message),\n  });\n}\n","import type { WalletClient } from 'viem';\nimport {\n  type Account,\n  type Client,\n  encodeAbiParameters,\n  encodeFunctionData,\n  type Hash,\n  type Hex,\n  keccak256,\n  parseAbiParameters,\n  serializeErc6492Signature,\n  toBytes,\n  type Transport,\n  zeroAddress,\n} from 'viem';\nimport { getCode, signTypedData } from 'viem/actions';\nimport type { ChainEIP712 } from 'viem/chains';\n\nimport AccountFactoryAbi from './abis/AccountFactory.js';\nimport {\n  EOA_VALIDATOR_ADDRESS,\n  SMART_ACCOUNT_FACTORY_ADDRESS,\n} from './constants.js';\nimport { getInitializerCalldata } from './utils.js';\n\nexport interface GetAgwTypedSignatureParams {\n  client: Client<Transport, ChainEIP712, Account>;\n  signer: WalletClient<Transport, ChainEIP712, Account>;\n  messageHash: Hash;\n}\n\nexport async function getAgwTypedSignature(\n  args: GetAgwTypedSignatureParams,\n): Promise<Hex> {\n  const { client, signer, messageHash } = args;\n  const chainId = client.chain.id;\n  const account = client.account;\n\n  const rawSignature = await signTypedData(signer, {\n    domain: {\n      name: 'AbstractGlobalWallet',\n      version: '1.0.0',\n      chainId: BigInt(chainId),\n      verifyingContract: account.address,\n    },\n    types: {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n      AGWMessage: [{ name: 'signedHash', type: 'bytes32' }],\n    },\n    message: {\n      signedHash: messageHash,\n    },\n    primaryType: 'AGWMessage',\n  });\n\n  const signature = encodeAbiParameters(\n    parseAbiParameters(['bytes', 'address']),\n    [rawSignature, EOA_VALIDATOR_ADDRESS],\n  );\n\n  const code = await getCode(client, {\n    address: account.address,\n  });\n\n  // if the account is already deployed, we can use signature directly\n  // otherwise, we provide an ERC-6492 compatible signature\n  if (code !== undefined) {\n    return signature;\n  }\n\n  // Generate the ERC-6492 compatible signature\n  // https://eips.ethereum.org/EIPS/eip-6492\n\n  // 1. Generate the salt for account deployment\n  const addressBytes = toBytes(signer.account.address);\n  const salt = keccak256(addressBytes);\n\n  // 2. Generate the ERC-6492 compatible signature with deploy parameters\n  return serializeErc6492Signature({\n    address: SMART_ACCOUNT_FACTORY_ADDRESS,\n    data: encodeFunctionData({\n      abi: AccountFactoryAbi,\n      functionName: 'deployAccount',\n      args: [\n        salt,\n        getInitializerCalldata(signer.account.address, EOA_VALIDATOR_ADDRESS, {\n          target: zeroAddress,\n          allowFailure: false,\n          callData: '0x',\n          value: 0n,\n        }),\n      ],\n    }),\n    signature,\n  });\n}\n","import {\n  type Account,\n  type Address,\n  BaseError,\n  type Client,\n  encodeAbiParameters,\n  type Hex,\n  parseAbiParameters,\n  type PublicClient,\n  type Transport,\n  type UnionRequiredBy,\n  type WalletClient,\n} from 'viem';\nimport { getChainId, readContract, signTypedData } from 'viem/actions';\nimport { assertCurrentChain, getAction, parseAccount } from 'viem/utils';\nimport {\n  type ChainEIP712,\n  type SignEip712TransactionParameters,\n  type SignEip712TransactionReturnType,\n  type TransactionRequestEIP712,\n} from 'viem/zksync';\n\nimport AGWAccountAbi from '../abis/AGWAccount.js';\nimport {\n  assertEip712Request,\n  type AssertEip712RequestParameters,\n} from '../eip712.js';\nimport { AccountNotFoundError } from '../errors/account.js';\nimport { assertSessionKeyPolicies } from '../sessionValidator.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { VALID_CHAINS } from '../utils.js';\nimport { transformHexValues } from '../utils.js';\nimport { signPrivyTransaction } from './sendPrivyTransaction.js';\n\nexport async function signTransaction<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  args: SignEip712TransactionParameters<chain, account, chainOverride>,\n  validator: Address,\n  validationHookData: Record<string, Hex> = {},\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n  isPrivyCrossApp = false,\n): Promise<SignEip712TransactionReturnType> {\n  const chain = client.chain;\n\n  if (isPrivyCrossApp) {\n    return signPrivyTransaction(client, args);\n  }\n\n  if (!chain?.serializers?.transaction)\n    throw new BaseError('transaction serializer not found on chain.');\n\n  const { transaction, customSignature } = await signEip712TransactionInternal(\n    client,\n    signerClient,\n    publicClient,\n    args,\n    validator,\n    validationHookData,\n    customPaymasterHandler,\n  );\n\n  return chain.serializers.transaction(\n    {\n      ...transaction,\n      customSignature,\n      type: 'eip712',\n    } as any,\n    { r: '0x0', s: '0x0', v: 0n },\n  ) as SignEip712TransactionReturnType;\n}\n\nexport async function signEip712TransactionInternal<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  args: SignEip712TransactionParameters<chain, account, chainOverride>,\n  validator: Address,\n  validationHookData: Record<string, Hex> = {},\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<{\n  transaction: UnionRequiredBy<TransactionRequestEIP712, 'from'> & {\n    chainId: number;\n  };\n  customSignature: Hex;\n}> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    ...transaction\n  } = args;\n  // TODO: open up typing to allow for eip712 transactions\n  transaction.type = 'eip712' as any;\n  transformHexValues(transaction, [\n    'value',\n    'nonce',\n    'maxFeePerGas',\n    'maxPriorityFeePerGas',\n    'gas',\n    'chainId',\n    'gasPerPubdata',\n  ]);\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTransaction',\n    });\n  const smartAccount = parseAccount(account_);\n  const useSignerAddress =\n    (transaction as any).from === signerClient.account.address;\n  const fromAccount = useSignerAddress ? signerClient.account : smartAccount;\n\n  assertEip712Request({\n    account: fromAccount,\n    chain,\n    ...(transaction as AssertEip712RequestParameters),\n  });\n\n  if (!chain || VALID_CHAINS[chain.id] === undefined) {\n    throw new BaseError('Invalid chain specified');\n  }\n\n  if (!chain?.custom?.getEip712Domain)\n    throw new BaseError('`getEip712Domain` not found on chain.');\n\n  const chainId = await getAction(client, getChainId, 'getChainId')({});\n  if (chain !== null)\n    assertCurrentChain({\n      currentChainId: chainId,\n      chain: chain,\n    });\n\n  await assertSessionKeyPolicies(\n    publicClient,\n    chainId,\n    fromAccount,\n    transaction,\n  );\n\n  const transactionWithPaymaster = await getTransactionWithPaymasterData(\n    chainId,\n    fromAccount,\n    transaction,\n    customPaymasterHandler,\n  );\n\n  if (transactionWithPaymaster.data === undefined) {\n    // serializer turns undefined into 0x00 which causes issues sending\n    // eth to contracts that don't have a fallback function\n    transactionWithPaymaster.data = '0x';\n  }\n\n  const eip712Domain = chain?.custom.getEip712Domain({\n    ...transactionWithPaymaster,\n    type: 'eip712',\n  });\n\n  const rawSignature = await signTypedData(signerClient, {\n    ...eip712Domain,\n    account: signerClient.account,\n  });\n\n  let signature;\n  if (useSignerAddress) {\n    signature = rawSignature;\n  } else {\n    const hookData: Hex[] = [];\n    if (!useSignerAddress) {\n      const validationHooks = await getAction(\n        client,\n        readContract,\n        'readContract',\n      )({\n        address: client.account.address,\n        abi: AGWAccountAbi,\n        functionName: 'listHooks',\n        args: [true],\n      });\n      for (const hook of validationHooks) {\n        hookData.push(validationHookData[hook] ?? '0x');\n      }\n    }\n    // Match the expect signature format of the AGW smart account\n    signature = encodeAbiParameters(\n      parseAbiParameters(['bytes', 'address', 'bytes[]']),\n      [rawSignature, validator, hookData],\n    );\n  }\n\n  return {\n    transaction: transactionWithPaymaster,\n    customSignature: signature,\n  };\n}\n\nasync function getTransactionWithPaymasterData(\n  chainId: number,\n  fromAccount: Account,\n  transaction: TransactionRequestEIP712,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<\n  UnionRequiredBy<TransactionRequestEIP712, 'from'> & { chainId: number }\n> {\n  if (\n    customPaymasterHandler &&\n    !transaction.paymaster &&\n    !transaction.paymasterInput\n  ) {\n    const paymasterResult = await customPaymasterHandler({\n      chainId,\n      from: fromAccount.address,\n      data: transaction.data,\n      gas: transaction.gas ?? 0n,\n      gasPrice: transaction.gasPrice ?? 0n,\n      gasPerPubdata: transaction.gasPerPubdata ?? 0n,\n      maxFeePerGas: transaction.maxFeePerGas ?? 0n,\n      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ?? 0n,\n      nonce: transaction.nonce ?? 0,\n      to: transaction.to ?? '0x0',\n      value: transaction.value ?? 0n,\n    });\n    return {\n      ...transaction,\n      ...paymasterResult,\n      from: fromAccount.address,\n      chainId,\n    };\n  }\n  return {\n    ...transaction,\n    from: fromAccount.address,\n    chainId,\n  };\n}\n","import {\n  type Account,\n  BaseError,\n  type PublicClient,\n  toFunctionSelector,\n  type Transport,\n} from 'viem';\nimport { abstract } from 'viem/chains';\nimport { decodeAbiParameters, decodeFunctionData } from 'viem/utils';\nimport type { ChainEIP712, SignEip712TransactionParameters } from 'viem/zksync';\n\nimport { SessionKeyPolicyRegistryAbi } from './abis/SessionKeyPolicyRegistry.js';\nimport { SessionKeyValidatorAbi } from './abis/SessionKeyValidator.js';\nimport {\n  ADD_MODULE_SELECTOR,\n  BATCH_CALL_SELECTOR,\n  CREATE_SESSION_SELECTOR,\n  SESSION_KEY_POLICY_REGISTRY_ADDRESS,\n  SESSION_KEY_VALIDATOR_ADDRESS,\n} from './constants.js';\nimport { AGWAccountAbi } from './exports/constants.js';\nimport { ConstraintCondition, getSessionSpec } from './sessions.js';\n\nconst restrictedSelectors = new Set<string>([\n  toFunctionSelector('function setApprovalForAll(address, bool)'),\n  toFunctionSelector('function approve(address, uint256)'),\n  toFunctionSelector('function transfer(address, uint256)'),\n]);\n\nexport enum SessionKeyPolicyStatus {\n  Unset = 0,\n  Allowed = 1,\n  Denied = 2,\n}\n\nexport async function assertSessionKeyPolicies<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account = Account,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: PublicClient<Transport, ChainEIP712>,\n  chainId: number,\n  account: account,\n  transaction: Omit<\n    SignEip712TransactionParameters<chain, account, chainOverride>,\n    'account' | 'chain'\n  >,\n) {\n  // Only validate on Abstract mainnet\n  if (chainId !== abstract.id) {\n    return;\n  }\n\n  const sessions = [];\n\n  if (\n    transaction.to === account.address &&\n    transaction.data?.substring(0, 10) === BATCH_CALL_SELECTOR\n  ) {\n    const batchCall = decodeFunctionData({\n      abi: AGWAccountAbi,\n      data: transaction.data,\n    });\n    if (batchCall.functionName === 'batchCall') {\n      for (const call of batchCall.args[0]) {\n        const subTransaction = {\n          ...transaction,\n          to: call.target,\n          data: call.callData,\n        };\n        const session = getSessionFromTransaction(account, subTransaction);\n        if (session) {\n          sessions.push(session);\n        }\n      }\n    }\n  } else {\n    const session = getSessionFromTransaction(account, transaction);\n    if (session) {\n      sessions.push(session);\n    }\n  }\n\n  if (sessions.length === 0) {\n    // no session can be parsed from the transaction\n    return;\n  }\n\n  for (const session of sessions) {\n    const callPolicies = session.callPolicies;\n    const transferPolicies = session.transferPolicies;\n\n    const checks = [];\n\n    for (const callPolicy of callPolicies) {\n      if (restrictedSelectors.has(callPolicy.selector)) {\n        const destinationConstraints = callPolicy.constraints.filter(\n          (c) => c.index === 0n && c.condition === ConstraintCondition.Equal,\n        );\n\n        if (destinationConstraints.length === 0) {\n          throw new BaseError(\n            `Unconstrained token approval/transfer destination in call policy. Selector: ${callPolicy.selector}; Target: ${callPolicy.target}`,\n          );\n        }\n\n        for (const constraint of destinationConstraints) {\n          const [target] = decodeAbiParameters(\n            [\n              {\n                type: 'address',\n              },\n            ],\n            constraint.refValue,\n          );\n\n          checks.push({\n            target,\n            check: {\n              address: SESSION_KEY_POLICY_REGISTRY_ADDRESS,\n              abi: SessionKeyPolicyRegistryAbi,\n              functionName: 'getApprovalTargetStatus',\n              args: [\n                callPolicy.target, // token address\n                target, // allowed spender\n              ],\n            },\n          });\n        }\n      } else {\n        checks.push({\n          target: callPolicy.target,\n          check: {\n            address: SESSION_KEY_POLICY_REGISTRY_ADDRESS,\n            abi: SessionKeyPolicyRegistryAbi,\n            functionName: 'getCallPolicyStatus',\n            args: [callPolicy.target, callPolicy.selector],\n          },\n        });\n      }\n    }\n\n    for (const transferPolicy of transferPolicies) {\n      checks.push({\n        target: transferPolicy.target,\n        check: {\n          address: SESSION_KEY_POLICY_REGISTRY_ADDRESS,\n          abi: SessionKeyPolicyRegistryAbi,\n          functionName: 'getTransferPolicyStatus',\n          args: [transferPolicy.target],\n        },\n      });\n    }\n\n    const results = await client.multicall({\n      contracts: checks.map((c) => c.check),\n      allowFailure: false,\n    });\n\n    for (let i = 0; i < checks.length; i++) {\n      const result = results[i];\n      const check = checks[i];\n\n      if (Number(result) !== SessionKeyPolicyStatus.Allowed) {\n        throw new BaseError(\n          `Session key policy violation. Target: ${check?.target}; Status: ${SessionKeyPolicyStatus[Number(result)]}`,\n        );\n      }\n    }\n  }\n}\n\nfunction getSessionFromTransaction<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  account: account,\n  transaction: Omit<\n    SignEip712TransactionParameters<chain, account, chainOverride>,\n    'account' | 'chain'\n  >,\n) {\n  if (\n    transaction.to === SESSION_KEY_VALIDATOR_ADDRESS &&\n    transaction.data?.substring(0, 10) === CREATE_SESSION_SELECTOR\n  ) {\n    const sessionSpec = decodeFunctionData({\n      abi: SessionKeyValidatorAbi,\n      data: transaction.data,\n    });\n    if (sessionSpec.functionName === 'createSession') {\n      return sessionSpec.args[0];\n    }\n  }\n\n  if (\n    transaction.to === account?.address &&\n    transaction.data?.substring(0, 10) === ADD_MODULE_SELECTOR\n  ) {\n    const moduleAndData = decodeFunctionData({\n      abi: AGWAccountAbi,\n      data: transaction.data,\n    });\n    if (\n      moduleAndData.functionName === 'addModule' &&\n      moduleAndData.args[0]\n        .toLowerCase()\n        .startsWith(SESSION_KEY_VALIDATOR_ADDRESS.toLowerCase())\n    ) {\n      // Remove '0x' prefix (2 chars) + validator address 20 bytes (40 chars)\n      const sessionData = moduleAndData.args[0].substring(42);\n\n      return decodeAbiParameters([getSessionSpec()], `0x${sessionData}`)[0];\n    }\n  }\n\n  return undefined;\n}\n","import {\n  type Account,\n  type Address,\n  type Client,\n  type Hex,\n  type PublicClient,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport {\n  type ChainEIP712,\n  type SignEip712TransactionReturnType,\n} from 'viem/zksync';\n\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport type { SignTransactionBatchParameters } from '../types/signTransactionBatch.js';\nimport { signPrivyTransaction } from './sendPrivyTransaction.js';\nimport { getBatchTransactionObject } from './sendTransactionBatch.js';\nimport { signTransaction } from './signTransaction.js';\n\n/**\n * Function to sign a batch of transactions in a single call using the connected Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { encodeFunctionData, parseUnits } from \"viem\";\n *\n * export default function SignTransactionBatch() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function signTransactionBatch() {\n *     if (!agwClient) return;\n *\n *     // Sign a batch of multiple transactions in a single call\n *     const rawTransaction = await agwClient.signTransactionBatch({\n *       calls: [\n *         // 1. Simple ETH transfer\n *         {\n *           to: \"0x1234567890123456789012345678901234567890\",\n *           value: parseUnits(\"0.1\", 18), // 0.1 ETH\n *         },\n *         // 2. Contract interaction\n *         {\n *           to: \"0xabcdef0123456789abcdef0123456789abcdef01\",\n *           data: encodeFunctionData({\n *             abi: [\n *               {\n *                 name: \"transfer\",\n *                 type: \"function\",\n *                 inputs: [\n *                   { name: \"to\", type: \"address\" },\n *                   { name: \"amount\", type: \"uint256\" }\n *                 ],\n *                 outputs: [{ type: \"bool\" }],\n *                 stateMutability: \"nonpayable\"\n *               }\n *             ],\n *             functionName: \"transfer\",\n *             args: [\"0x9876543210987654321098765432109876543210\", parseUnits(\"10\", 18)]\n *           })\n *         }\n *       ]\n *     });\n *\n *     console.log(\"Serialized transaction:\", rawTransaction);\n *   }\n * }\n * ```\n *\n * @param parameters - Parameters for signing a batch of transactions\n * @param parameters.calls - An array of transaction requests. Each transaction can include:\n *   - to: The recipient address (required)\n *   - data: Contract code or method call with encoded args\n *   - value: Amount in wei to send\n * @param parameters.paymaster - Address of the paymaster smart contract that will pay the gas fees\n * @param parameters.paymasterInput - Input data to the paymaster\n * @returns The transaction hash of the submitted transaction batch\n */\nexport async function signTransactionBatch<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SignTransactionBatchParameters<chain, account, chainOverride>,\n  validator: Address,\n  validationHookData: Record<string, Hex> = {},\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n  isPrivyCrossApp = false,\n): Promise<SignEip712TransactionReturnType> {\n  const { calls, ...rest } = parameters;\n  if (calls.length === 0) {\n    throw new Error('No calls provided');\n  }\n  if (isPrivyCrossApp) {\n    return await signPrivyTransaction(client, parameters);\n  }\n\n  const batchTransaction = getBatchTransactionObject(\n    client.account.address,\n    parameters,\n  );\n\n  return signTransaction(\n    client,\n    signerClient,\n    publicClient,\n    {\n      ...batchTransaction,\n      ...rest,\n    },\n    validator,\n    validationHookData,\n    customPaymasterHandler,\n  );\n}\n","import {\n  type Account,\n  BaseError,\n  type Client,\n  type Hex,\n  type PublicClient,\n  type SendTransactionRequest,\n  type Transport,\n  type WalletClient,\n} from 'viem';\nimport {\n  type ChainEIP712,\n  type SendEip712TransactionParameters,\n  type SignEip712TransactionParameters,\n  type SignTransactionReturnType,\n} from 'viem/zksync';\n\nimport { SESSION_KEY_VALIDATOR_ADDRESS } from '../constants.js';\nimport {\n  encodeSessionWithPeriodIds,\n  getPeriodIdsForTransaction,\n  type SessionConfig,\n} from '../sessions.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { isSmartAccountDeployed } from '../utils.js';\nimport { signTransaction } from './signTransaction.js';\n\nexport interface SendTransactionForSessionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> {\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >;\n  session: SessionConfig;\n}\n\nexport async function signTransactionForSession<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: SignEip712TransactionParameters<chain, account, chainOverride>,\n  session: SessionConfig,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<SignTransactionReturnType> {\n  const isDeployed = await isSmartAccountDeployed(\n    publicClient,\n    client.account.address,\n  );\n  if (!isDeployed) {\n    throw new BaseError('Smart account not deployed');\n  }\n\n  const selector: Hex | undefined = parameters.data\n    ? `0x${parameters.data.slice(2, 10)}`\n    : undefined;\n\n  if (!parameters.to) {\n    throw new BaseError('Transaction to field is not specified');\n  }\n\n  return await signTransaction(\n    client,\n    signerClient,\n    publicClient,\n    parameters,\n    SESSION_KEY_VALIDATOR_ADDRESS,\n    {\n      [SESSION_KEY_VALIDATOR_ADDRESS]: encodeSessionWithPeriodIds(\n        session,\n        getPeriodIdsForTransaction({\n          sessionConfig: session,\n          target: parameters.to,\n          selector,\n          timestamp: BigInt(Math.floor(Date.now() / 1000)),\n        }),\n      ),\n    },\n    customPaymasterHandler,\n  );\n}\n","import {\n  type Account,\n  BaseError,\n  type Client,\n  fromRlp,\n  hashTypedData,\n  type Hex,\n  type PublicClient,\n  type Transport,\n  type TypedData,\n  type TypedDataDefinition,\n  type WalletClient,\n} from 'viem';\nimport { type SignTypedDataParameters } from 'viem/accounts';\nimport type { ChainEIP712 } from 'viem/chains';\n\nimport {\n  EOA_VALIDATOR_ADDRESS,\n  SESSION_KEY_VALIDATOR_ADDRESS,\n} from '../constants.js';\nimport { getAgwTypedSignature } from '../getAgwTypedSignature.js';\nimport {\n  encodeSessionWithPeriodIds,\n  getPeriodIdsForTransaction,\n  type SessionConfig,\n} from '../sessions.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { isEip712TypedData, transformEip712TypedData } from '../utils.js';\nimport { sendPrivySignTypedData } from './sendPrivyTransaction.js';\nimport {\n  signEip712TransactionInternal,\n  signTransaction,\n} from './signTransaction.js';\n\nexport async function signTypedData(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: Omit<SignTypedDataParameters, 'account' | 'privateKey'>,\n  isPrivyCrossApp = false,\n): Promise<Hex> {\n  // if the typed data is already a zkSync EIP712 transaction, don't try to transform it\n  // to an AGW typed signature, just pass it through to the signer.\n  if (isEip712TypedData(parameters)) {\n    const transformedTypedData = transformEip712TypedData(parameters);\n\n    if (transformedTypedData.chainId !== client.chain.id) {\n      throw new BaseError('Chain ID mismatch in AGW typed signature');\n    }\n\n    const signedTransaction = await signTransaction(\n      client,\n      signerClient,\n      publicClient,\n      {\n        ...transformedTypedData,\n        chain: client.chain,\n      },\n      EOA_VALIDATOR_ADDRESS,\n      {},\n      undefined,\n      isPrivyCrossApp,\n    );\n\n    if (!signedTransaction.startsWith('0x71')) {\n      throw new BaseError(\n        'Expected RLP encoded EIP-712 transaction as signature',\n      );\n    }\n\n    const rlpSignature: Hex = `0x${signedTransaction.slice(4)}`;\n\n    const signatureParts = fromRlp(rlpSignature, 'hex');\n    if (signatureParts.length < 15) {\n      throw new BaseError(\n        'Expected RLP encoded EIP-712 transaction with at least 15 fields',\n      );\n    }\n    // This is somewhat not type safe as it assumes that the signature from signTransaction is an\n    // RLP encoded 712 transaction and that the customSignature field is the 15th field in the transaction.\n    // That being said, it's a safe assumption for the current use case.\n    return signatureParts[14] as Hex;\n  } else if (isPrivyCrossApp) {\n    return await sendPrivySignTypedData(client, parameters);\n  }\n\n  return await getAgwTypedSignature({\n    client,\n    signer: signerClient,\n    messageHash: hashTypedData(parameters),\n  });\n}\n\nexport async function signTypedDataForSession<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends string,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: TypedDataDefinition<typedData, primaryType>,\n  session: SessionConfig,\n  paymasterHandler?: CustomPaymasterHandler,\n): Promise<Hex> {\n  // if the typed data is already a zkSync EIP712 transaction, don't try to transform it\n  // to an AGW typed signature, just pass it through to the signer.\n  if (!isEip712TypedData(parameters as any)) {\n    throw new BaseError(\n      'Session client can only sign EIP712 transactions as typed data',\n    );\n  }\n\n  const transactionRequest = transformEip712TypedData(parameters as any);\n\n  if (!transactionRequest.to) {\n    throw new BaseError('Transaction must have a to address');\n  }\n\n  // Match the expect signature format of the AGW smart account so the result can be\n  // directly used in eth_sendRawTransaction as the customSignature field\n  const validationHookData = {\n    [SESSION_KEY_VALIDATOR_ADDRESS]: encodeSessionWithPeriodIds(\n      session,\n      getPeriodIdsForTransaction({\n        sessionConfig: session,\n        target: transactionRequest.to,\n        selector: (transactionRequest.data?.slice(0, 10) ?? '0x') as Hex,\n        timestamp: BigInt(Math.floor(Date.now() / 1000)),\n      }),\n    ),\n  };\n\n  const { customSignature } = await signEip712TransactionInternal(\n    client,\n    signerClient,\n    publicClient,\n    {\n      chain: client.chain,\n      ...transactionRequest,\n    },\n    SESSION_KEY_VALIDATOR_ADDRESS,\n    validationHookData,\n    paymasterHandler,\n  );\n\n  return customSignature;\n}\n","import {\n  type Abi,\n  type Account,\n  BaseError,\n  type Client,\n  type ContractFunctionArgs,\n  type ContractFunctionName,\n  encodeFunctionData,\n  type EncodeFunctionDataParameters,\n  type PublicClient,\n  type Transport,\n  type WalletClient,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n} from 'viem';\nimport { getContractError, parseAccount } from 'viem/utils';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport { AccountNotFoundError } from '../errors/account.js';\nimport { sendTransaction } from './sendTransaction.js';\n\n/**\n * Function to call functions on a smart contract using the connected Abstract Global Wallet.\n *\n * @example\n * ```tsx\n * import { useAbstractClient } from \"@abstract-foundation/agw-react\";\n * import { parseAbi } from \"viem\";\n *\n * export default function WriteContract() {\n *   const { data: agwClient } = useAbstractClient();\n *\n *   async function writeContract() {\n *     if (!agwClient) return;\n *\n *     const transactionHash = await agwClient.writeContract({\n *       abi: parseAbi([\"function mint(address,uint256) external\"]), // Your contract ABI\n *       address: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\",\n *       functionName: \"mint\",\n *       args: [\"0x273B3527BF5b607dE86F504fED49e1582dD2a1C6\", BigInt(1)],\n *     });\n *\n *     console.log(\"Transaction hash:\", transactionHash);\n *   }\n * }\n * ```\n *\n * @param parameters - Parameters for writing to a contract\n * @param parameters.address - The address of the contract to write to (required)\n * @param parameters.abi - The ABI of the contract to write to (required)\n * @param parameters.functionName - The name of the function to call on the contract (required)\n * @param parameters.args - The arguments to pass to the function\n * @param parameters.account - The account to use for the transaction (defaults to the AGW's account)\n * @param parameters.chain - The chain to use for the transaction (defaults to the chain in the AbstractClient)\n * @param parameters.value - The amount of native token to send with the transaction (in wei)\n * @param parameters.dataSuffix - Data to append to the end of the calldata\n * @param parameters.gasPerPubdata - The amount of gas to pay per byte of data on Ethereum\n * @param parameters.paymaster - Address of the paymaster smart contract that will pay the gas fees\n * @param parameters.paymasterInput - Input data to the paymaster (required if paymaster is provided)\n * @returns The transaction hash of the contract write operation\n */\nexport async function writeContract<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n  isPrivyCrossApp = false,\n): Promise<WriteContractReturnType> {\n  const {\n    abi,\n    account: account_ = client.account,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...request\n  } = parameters as WriteContractParameters;\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/contract/writeContract',\n    });\n  const account = parseAccount(account_);\n\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters);\n\n  try {\n    return await sendTransaction(\n      client,\n      signerClient,\n      publicClient,\n      {\n        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n        to: address,\n        account,\n        ...request,\n      },\n      isPrivyCrossApp,\n    );\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/writeContract',\n      functionName,\n      sender: account.address,\n    });\n  }\n}\n","import {\n  type Abi,\n  type Account,\n  BaseError,\n  type Client,\n  type ContractFunctionArgs,\n  type ContractFunctionName,\n  encodeFunctionData,\n  type EncodeFunctionDataParameters,\n  type PublicClient,\n  type Transport,\n  type WalletClient,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n} from 'viem';\nimport { getContractError, parseAccount } from 'viem/utils';\nimport { type ChainEIP712 } from 'viem/zksync';\n\nimport { AccountNotFoundError } from '../errors/account.js';\nimport type { SessionConfig } from '../sessions.js';\nimport type { CustomPaymasterHandler } from '../types/customPaymaster.js';\nimport { sendTransactionForSession } from './sendTransactionForSession.js';\n\nexport async function writeContractForSession<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, ChainEIP712, Account>,\n  signerClient: WalletClient<Transport, ChainEIP712, Account>,\n  publicClient: PublicClient<Transport, ChainEIP712>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n  session: SessionConfig,\n  customPaymasterHandler: CustomPaymasterHandler | undefined = undefined,\n): Promise<WriteContractReturnType> {\n  const {\n    abi,\n    account: account_ = client.account,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...request\n  } = parameters as WriteContractParameters;\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/contract/writeContract',\n    });\n  const account = parseAccount(account_);\n\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters);\n\n  try {\n    return await sendTransactionForSession(\n      client,\n      signerClient,\n      publicClient,\n      {\n        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n        to: address,\n        account,\n        ...request,\n      },\n      session,\n      customPaymasterHandler,\n    );\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/writeContract',\n      functionName,\n      sender: account.address,\n    });\n  }\n}\n","import { FastMCP } from \"fastmcp\";\nimport { randomBytes } from \"crypto\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { z } from \"zod\";\n\n// No params needed, but FastMCP requires a schema\nconst EmptySchema = z.object({}).describe(\"No parameters required\");\n\ntype Params = z.infer<typeof EmptySchema>;\n\nexport function registerGenerateEoaWallet(server: FastMCP) {\n    server.addTool({\n        name: \"ab_generate_wallet\",\n        description: `Generate a brand-new Externally Owned Account (EOA).\n\nRETURNS\nâ€¢ privateKey â€“ 0x-prefixed 32-byte hex string\nâ€¢ address â€“ checksummed Ethereum/Abstract address\n\nCOMMON USES\nâ€¢ Let agents spin up their own keypairs before funding or deploying smart-accounts.\n\nSECURITY\nâ€¢ The private key is returned in plaintext. Ensure the caller stores it securely and never logs it.`,\n        parameters: EmptySchema,\n        annotations: { destructiveHint: false, title: \"Generate EOA Wallet\" },\n        execute: async (_args: Params, _ctx) => {\n            // Generate 32 random bytes\n            const pkBytes = randomBytes(32);\n            const privateKey = `0x${pkBytes.toString(\"hex\")}` as `0x${string}`;\n            const account = privateKeyToAccount(privateKey);\n            return {\n                content: [\n                    {\n                        type: \"text\",\n                        text: JSON.stringify({ privateKey, address: account.address }),\n                    },\n                ],\n            };\n        },\n    });\n} "],"mappings":"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","names":["FastMCP","dotenv","server","z","UserError","ParamsSchema","z","server","UserError","formatted","z","UserError","ERC20_ABI","ParamsSchema","z","server","UserError","hash","z","UserError","encodeFunctionData","keccak256","toBytes","abstractTestnet","abstractTestnet","BaseError","abstract","abstractTestnet","abstractTestnet","abstract","toBytes","keccak256","encodeFunctionData","isAddress","parseAccount","BaseError","BaseError","getAddress","InvalidAddressError","isAddress","readContract","getAction","parseAccount","getAddress","keccak256","LimitType","ConstraintCondition","SessionStatus","createPublicClient","encodeFunctionData","http","getAction","parseAccount","encodeFunctionData","toHex","BaseError","getChainId","assertCurrentChain","getAction","getTransactionError","parseAccount","BaseError","BaseError","encodeFunctionData","keccak256","toBytes","assertRequest","getAction","parseAccount","createClient","createPublicClient","createWalletClient","http","toAccount","parseAccount","getChainId","createPublicClient","createWalletClient","http","readContract","writeContract","getAction","BaseError","parseAccount","writeContract","getAction","BaseError","fromHex","encodeAbiParameters","encodeFunctionData","keccak256","toBytes","zeroAddress","BaseError","encodeAbiParameters","parseAbiParameters","readContract","signTypedData","getAction","parseAccount","BaseError","abstract","SessionKeyPolicyStatus","BaseError","BaseError","BaseError","encodeFunctionData","parseAccount","BaseError","encodeFunctionData","getContractError","parseAccount","ParamsSchema","z","server","UserError","privateKeyToAccount","z","server","FastMCP"]}